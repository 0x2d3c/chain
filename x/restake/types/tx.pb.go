// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: restake/v1beta1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgClaimRewards is the request message type for claiming rewards.
type MsgClaimRewards struct {
	// StakerAddress is the address that will claim the rewards.
	StakerAddress string `protobuf:"bytes,1,opt,name=staker_address,json=stakerAddress,proto3" json:"staker_address,omitempty"`
	// Key is the key that want to claim rewards from.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MsgClaimRewards) Reset()         { *m = MsgClaimRewards{} }
func (m *MsgClaimRewards) String() string { return proto.CompactTextString(m) }
func (*MsgClaimRewards) ProtoMessage()    {}
func (*MsgClaimRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{0}
}
func (m *MsgClaimRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimRewards.Merge(m, src)
}
func (m *MsgClaimRewards) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimRewards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimRewards proto.InternalMessageInfo

func (m *MsgClaimRewards) GetStakerAddress() string {
	if m != nil {
		return m.StakerAddress
	}
	return ""
}

func (m *MsgClaimRewards) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// MsgClaimRewardsResponse is the response message type for claiming rewards.
type MsgClaimRewardsResponse struct {
}

func (m *MsgClaimRewardsResponse) Reset()         { *m = MsgClaimRewardsResponse{} }
func (m *MsgClaimRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimRewardsResponse) ProtoMessage()    {}
func (*MsgClaimRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{1}
}
func (m *MsgClaimRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimRewardsResponse.Merge(m, src)
}
func (m *MsgClaimRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimRewardsResponse proto.InternalMessageInfo

// MsgLockPower is the request message type for locking tokens.
type MsgLockPower struct {
	// StakerAddress is the address will be locked power.
	StakerAddress string `protobuf:"bytes,1,opt,name=staker_address,json=stakerAddress,proto3" json:"staker_address,omitempty"`
	// Key is the key that power will be locked to.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Amount is the power amount that will be locked.
	Amount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount"`
}

func (m *MsgLockPower) Reset()         { *m = MsgLockPower{} }
func (m *MsgLockPower) String() string { return proto.CompactTextString(m) }
func (*MsgLockPower) ProtoMessage()    {}
func (*MsgLockPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{2}
}
func (m *MsgLockPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLockPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLockPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLockPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLockPower.Merge(m, src)
}
func (m *MsgLockPower) XXX_Size() int {
	return m.Size()
}
func (m *MsgLockPower) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLockPower.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLockPower proto.InternalMessageInfo

func (m *MsgLockPower) GetStakerAddress() string {
	if m != nil {
		return m.StakerAddress
	}
	return ""
}

func (m *MsgLockPower) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// MsgLockPowerResponse is the response message type for locking power.
type MsgLockPowerResponse struct {
}

func (m *MsgLockPowerResponse) Reset()         { *m = MsgLockPowerResponse{} }
func (m *MsgLockPowerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgLockPowerResponse) ProtoMessage()    {}
func (*MsgLockPowerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{3}
}
func (m *MsgLockPowerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLockPowerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLockPowerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLockPowerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLockPowerResponse.Merge(m, src)
}
func (m *MsgLockPowerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgLockPowerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLockPowerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLockPowerResponse proto.InternalMessageInfo

// MsgAddRewards is the request message type for adding rewards.
type MsgAddRewards struct {
	// Sender is the address that want to send rewards.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Key is the key of pool that reward will be sent to.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// Rewards is a list of rewards that will send to module.
	Rewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"min_deposit,omitempty"`
}

func (m *MsgAddRewards) Reset()         { *m = MsgAddRewards{} }
func (m *MsgAddRewards) String() string { return proto.CompactTextString(m) }
func (*MsgAddRewards) ProtoMessage()    {}
func (*MsgAddRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{4}
}
func (m *MsgAddRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddRewards.Merge(m, src)
}
func (m *MsgAddRewards) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddRewards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddRewards proto.InternalMessageInfo

func (m *MsgAddRewards) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgAddRewards) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *MsgAddRewards) GetRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Rewards
	}
	return nil
}

// MsgAddRewardsResponse is the response message type for adding rewards.
type MsgAddRewardsResponse struct {
}

func (m *MsgAddRewardsResponse) Reset()         { *m = MsgAddRewardsResponse{} }
func (m *MsgAddRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddRewardsResponse) ProtoMessage()    {}
func (*MsgAddRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{5}
}
func (m *MsgAddRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddRewardsResponse.Merge(m, src)
}
func (m *MsgAddRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddRewardsResponse proto.InternalMessageInfo

// MsgDeactivateKey is the request message type for deactivating a key.
type MsgDeactivateKey struct {
	// Sender is the sender of the message.
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Key is the key that will be deactivated.
	Key string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MsgDeactivateKey) Reset()         { *m = MsgDeactivateKey{} }
func (m *MsgDeactivateKey) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateKey) ProtoMessage()    {}
func (*MsgDeactivateKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{6}
}
func (m *MsgDeactivateKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateKey.Merge(m, src)
}
func (m *MsgDeactivateKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateKey proto.InternalMessageInfo

func (m *MsgDeactivateKey) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgDeactivateKey) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// MsgDeactivateKeyResponse is the response message type for deactivating a key.
type MsgDeactivateKeyResponse struct {
}

func (m *MsgDeactivateKeyResponse) Reset()         { *m = MsgDeactivateKeyResponse{} }
func (m *MsgDeactivateKeyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateKeyResponse) ProtoMessage()    {}
func (*MsgDeactivateKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c6a768b7b224a47, []int{7}
}
func (m *MsgDeactivateKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateKeyResponse.Merge(m, src)
}
func (m *MsgDeactivateKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateKeyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgClaimRewards)(nil), "restake.v1beta1.MsgClaimRewards")
	proto.RegisterType((*MsgClaimRewardsResponse)(nil), "restake.v1beta1.MsgClaimRewardsResponse")
	proto.RegisterType((*MsgLockPower)(nil), "restake.v1beta1.MsgLockPower")
	proto.RegisterType((*MsgLockPowerResponse)(nil), "restake.v1beta1.MsgLockPowerResponse")
	proto.RegisterType((*MsgAddRewards)(nil), "restake.v1beta1.MsgAddRewards")
	proto.RegisterType((*MsgAddRewardsResponse)(nil), "restake.v1beta1.MsgAddRewardsResponse")
	proto.RegisterType((*MsgDeactivateKey)(nil), "restake.v1beta1.MsgDeactivateKey")
	proto.RegisterType((*MsgDeactivateKeyResponse)(nil), "restake.v1beta1.MsgDeactivateKeyResponse")
}

func init() { proto.RegisterFile("restake/v1beta1/tx.proto", fileDescriptor_4c6a768b7b224a47) }

var fileDescriptor_4c6a768b7b224a47 = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0x31, 0x6f, 0xd3, 0x4e,
	0x14, 0x8f, 0x1b, 0xa9, 0x7f, 0xf5, 0xfe, 0x2d, 0x2d, 0x56, 0x4a, 0x5c, 0x4b, 0x38, 0xc5, 0x52,
	0xab, 0x50, 0xb5, 0xbe, 0x36, 0x6c, 0x11, 0x12, 0x6a, 0xca, 0x12, 0x20, 0x12, 0x98, 0x4e, 0x95,
	0x50, 0x74, 0xb1, 0x4f, 0xae, 0x95, 0xfa, 0x2e, 0xf2, 0x5d, 0xd3, 0x66, 0x41, 0x88, 0x91, 0x89,
	0x85, 0x2f, 0xc1, 0xd4, 0xa1, 0x1f, 0xa2, 0x63, 0xd5, 0x09, 0x31, 0x04, 0x94, 0x08, 0x55, 0xf0,
	0x11, 0x98, 0x90, 0xed, 0xb3, 0xe3, 0x58, 0xa1, 0x61, 0x80, 0xc5, 0xbe, 0x7b, 0xbf, 0xf7, 0x7e,
	0xef, 0xbd, 0xdf, 0xbd, 0x3b, 0xa0, 0xf8, 0x98, 0x71, 0xd4, 0xc6, 0xb0, 0xbb, 0xd3, 0xc2, 0x1c,
	0xed, 0x40, 0x7e, 0x6a, 0x74, 0x7c, 0xca, 0xa9, 0xbc, 0x28, 0x10, 0x43, 0x20, 0xea, 0x6d, 0xe4,
	0xb9, 0x84, 0xc2, 0xf0, 0x1b, 0xf9, 0xa8, 0x9a, 0x45, 0x99, 0x47, 0x19, 0x6c, 0x21, 0x36, 0x62,
	0xb0, 0xa8, 0x4b, 0x04, 0x5e, 0x14, 0xb8, 0xc7, 0x1c, 0xd8, 0xdd, 0x09, 0x7e, 0x02, 0x58, 0x89,
	0x80, 0x66, 0xb8, 0x83, 0xd1, 0x46, 0x40, 0x05, 0x87, 0x3a, 0x34, 0xb2, 0x07, 0xab, 0xc8, 0xaa,
	0x7f, 0x90, 0xc0, 0x62, 0x83, 0x39, 0x7b, 0x47, 0xc8, 0xf5, 0x4c, 0x7c, 0x82, 0x7c, 0x9b, 0xc9,
	0x8f, 0xc0, 0xad, 0xb0, 0x42, 0xbf, 0x89, 0x6c, 0xdb, 0xc7, 0x8c, 0x29, 0xd2, 0xaa, 0x54, 0x9e,
	0xab, 0x29, 0x57, 0xe7, 0x5b, 0x05, 0xc1, 0xb9, 0x1b, 0x21, 0x2f, 0xb9, 0xef, 0x12, 0xc7, 0x5c,
	0x88, 0xfc, 0x85, 0x51, 0x5e, 0x02, 0xf9, 0x36, 0xee, 0x29, 0x33, 0x41, 0x94, 0x19, 0x2c, 0xab,
	0xf0, 0xed, 0xf5, 0xd9, 0x46, 0x86, 0xf5, 0xdd, 0xf5, 0xd9, 0x46, 0x31, 0x96, 0x29, 0x53, 0x83,
	0xbe, 0x02, 0x8a, 0x19, 0x93, 0x89, 0x59, 0x87, 0x12, 0x86, 0xf5, 0x6f, 0x12, 0x98, 0x6f, 0x30,
	0xe7, 0x19, 0xb5, 0xda, 0xcf, 0xe9, 0x09, 0xf6, 0xff, 0x41, 0xbd, 0xf2, 0x3e, 0x98, 0x45, 0x1e,
	0x3d, 0x26, 0x5c, 0xc9, 0x87, 0x54, 0x0f, 0x2f, 0xfa, 0xa5, 0xdc, 0xe7, 0x7e, 0x69, 0xdd, 0x71,
	0xf9, 0xe1, 0x71, 0xcb, 0xb0, 0xa8, 0x27, 0xd4, 0x15, 0xbf, 0x2d, 0x66, 0xb7, 0x21, 0xef, 0x75,
	0x30, 0x33, 0xea, 0x84, 0x5f, 0x9d, 0x6f, 0x01, 0x91, 0xb8, 0x4e, 0xb8, 0x29, 0xb8, 0xaa, 0x9b,
	0xbf, 0x51, 0xa1, 0x90, 0x52, 0x21, 0x69, 0x4b, 0xbf, 0x03, 0x0a, 0xe9, 0x7d, 0xd2, 0xff, 0x4f,
	0x09, 0x2c, 0x34, 0x98, 0xb3, 0x6b, 0xdb, 0xf1, 0x81, 0x6d, 0x83, 0x59, 0x86, 0x89, 0x8d, 0xfd,
	0xa9, 0x8d, 0x0b, 0xbf, 0x09, 0x1d, 0xbf, 0x06, 0xff, 0xf9, 0x11, 0x9d, 0x92, 0x5f, 0xcd, 0x97,
	0xff, 0xaf, 0xac, 0x18, 0x82, 0x21, 0x18, 0xc2, 0x78, 0x58, 0x8d, 0x3d, 0xea, 0x92, 0x5a, 0x3d,
	0x50, 0xe3, 0x47, 0xbf, 0xb4, 0xec, 0xb9, 0xa4, 0x69, 0xe3, 0x0e, 0x65, 0x2e, 0xdf, 0xa4, 0x9e,
	0xcb, 0xb1, 0xd7, 0xe1, 0xbd, 0x8f, 0x5f, 0x4a, 0xe5, 0x3f, 0x90, 0x29, 0x60, 0x62, 0x66, 0x9c,
	0xb4, 0xba, 0x16, 0x68, 0x23, 0xca, 0x0b, 0x34, 0x59, 0x4e, 0x69, 0x32, 0x6a, 0x55, 0x2f, 0x82,
	0xe5, 0x31, 0x43, 0xa2, 0xca, 0x1b, 0x09, 0x2c, 0x35, 0x98, 0xf3, 0x18, 0x23, 0x8b, 0xbb, 0x5d,
	0xc4, 0xf1, 0x53, 0xdc, 0xfb, 0x1b, 0xc2, 0x54, 0xcb, 0x99, 0xc2, 0x94, 0x54, 0x61, 0x63, 0xd9,
	0x74, 0x15, 0x28, 0x59, 0x5b, 0x5c, 0x5e, 0xe5, 0xfb, 0x0c, 0xc8, 0x37, 0x98, 0x23, 0x1f, 0x80,
	0xf9, 0xb1, 0xbb, 0xb6, 0x6a, 0x64, 0x9e, 0x03, 0x23, 0x33, 0xf6, 0x6a, 0x79, 0x9a, 0x47, 0x9c,
	0x43, 0x7e, 0x01, 0xe6, 0x46, 0x97, 0xe2, 0xee, 0xa4, 0xb0, 0x04, 0x56, 0xd7, 0x6e, 0x84, 0x13,
	0xca, 0x7d, 0x00, 0x52, 0x73, 0xa6, 0x4d, 0x0a, 0x1a, 0xe1, 0xea, 0xfa, 0xcd, 0x78, 0xc2, 0xfa,
	0x0a, 0x2c, 0x8c, 0x9f, 0xd3, 0xbd, 0x49, 0x81, 0x63, 0x2e, 0xea, 0xfd, 0xa9, 0x2e, 0x31, 0x7d,
	0xed, 0xc9, 0xc5, 0x40, 0x93, 0x2e, 0x07, 0x9a, 0xf4, 0x75, 0xa0, 0x49, 0xef, 0x87, 0x5a, 0xee,
	0x72, 0xa8, 0xe5, 0x3e, 0x0d, 0xb5, 0xdc, 0xc1, 0x76, 0x6a, 0x2e, 0x5b, 0x88, 0xd8, 0xe1, 0x1b,
	0x68, 0xd1, 0x23, 0x68, 0x1d, 0x22, 0x97, 0xc0, 0x6e, 0x05, 0x9e, 0xc2, 0xf8, 0x78, 0xc3, 0x29,
	0x6d, 0xcd, 0x86, 0x2e, 0x0f, 0x7e, 0x05, 0x00, 0x00, 0xff, 0xff, 0x46, 0xd6, 0xe8, 0xa1, 0xd0,
	0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RPC method for claiming rewards.
	ClaimRewards(ctx context.Context, in *MsgClaimRewards, opts ...grpc.CallOption) (*MsgClaimRewardsResponse, error)
	// RPC method for locking powers.
	LockPower(ctx context.Context, in *MsgLockPower, opts ...grpc.CallOption) (*MsgLockPowerResponse, error)
	// RPC method for adding rewards.
	AddRewards(ctx context.Context, in *MsgAddRewards, opts ...grpc.CallOption) (*MsgAddRewardsResponse, error)
	// RPC method for deactivating a key.
	DeactivateKey(ctx context.Context, in *MsgDeactivateKey, opts ...grpc.CallOption) (*MsgDeactivateKeyResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) ClaimRewards(ctx context.Context, in *MsgClaimRewards, opts ...grpc.CallOption) (*MsgClaimRewardsResponse, error) {
	out := new(MsgClaimRewardsResponse)
	err := c.cc.Invoke(ctx, "/restake.v1beta1.Msg/ClaimRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LockPower(ctx context.Context, in *MsgLockPower, opts ...grpc.CallOption) (*MsgLockPowerResponse, error) {
	out := new(MsgLockPowerResponse)
	err := c.cc.Invoke(ctx, "/restake.v1beta1.Msg/LockPower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddRewards(ctx context.Context, in *MsgAddRewards, opts ...grpc.CallOption) (*MsgAddRewardsResponse, error) {
	out := new(MsgAddRewardsResponse)
	err := c.cc.Invoke(ctx, "/restake.v1beta1.Msg/AddRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeactivateKey(ctx context.Context, in *MsgDeactivateKey, opts ...grpc.CallOption) (*MsgDeactivateKeyResponse, error) {
	out := new(MsgDeactivateKeyResponse)
	err := c.cc.Invoke(ctx, "/restake.v1beta1.Msg/DeactivateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RPC method for claiming rewards.
	ClaimRewards(context.Context, *MsgClaimRewards) (*MsgClaimRewardsResponse, error)
	// RPC method for locking powers.
	LockPower(context.Context, *MsgLockPower) (*MsgLockPowerResponse, error)
	// RPC method for adding rewards.
	AddRewards(context.Context, *MsgAddRewards) (*MsgAddRewardsResponse, error)
	// RPC method for deactivating a key.
	DeactivateKey(context.Context, *MsgDeactivateKey) (*MsgDeactivateKeyResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) ClaimRewards(ctx context.Context, req *MsgClaimRewards) (*MsgClaimRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimRewards not implemented")
}
func (*UnimplementedMsgServer) LockPower(ctx context.Context, req *MsgLockPower) (*MsgLockPowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockPower not implemented")
}
func (*UnimplementedMsgServer) AddRewards(ctx context.Context, req *MsgAddRewards) (*MsgAddRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRewards not implemented")
}
func (*UnimplementedMsgServer) DeactivateKey(ctx context.Context, req *MsgDeactivateKey) (*MsgDeactivateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateKey not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_ClaimRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimRewards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/restake.v1beta1.Msg/ClaimRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimRewards(ctx, req.(*MsgClaimRewards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LockPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLockPower)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LockPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/restake.v1beta1.Msg/LockPower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LockPower(ctx, req.(*MsgLockPower))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddRewards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/restake.v1beta1.Msg/AddRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddRewards(ctx, req.(*MsgAddRewards))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeactivateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeactivateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeactivateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/restake.v1beta1.Msg/DeactivateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeactivateKey(ctx, req.(*MsgDeactivateKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "restake.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ClaimRewards",
			Handler:    _Msg_ClaimRewards_Handler,
		},
		{
			MethodName: "LockPower",
			Handler:    _Msg_LockPower_Handler,
		},
		{
			MethodName: "AddRewards",
			Handler:    _Msg_AddRewards_Handler,
		},
		{
			MethodName: "DeactivateKey",
			Handler:    _Msg_DeactivateKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "restake/v1beta1/tx.proto",
}

func (m *MsgClaimRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddress) > 0 {
		i -= len(m.StakerAddress)
		copy(dAtA[i:], m.StakerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.StakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgLockPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLockPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLockPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddress) > 0 {
		i -= len(m.StakerAddress)
		copy(dAtA[i:], m.StakerAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.StakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgLockPowerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLockPowerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLockPowerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgClaimRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgLockPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgLockPowerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgAddRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeactivateKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeactivateKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgClaimRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLockPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLockPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLockPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLockPowerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLockPowerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLockPowerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, types.Coin{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
