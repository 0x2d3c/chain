// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tss/v1beta1/tss.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_bandprotocol_chain_v2_pkg_tss "github.com/bandprotocol/chain/v2/pkg/tss"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SigningStatus is an enumeration of the possible statuses of a singing.
type SigningStatus int32

const (
	// SIGNING_STATUS_UNSPECIFIED is the status of a signing that has not been specified.
	SIGNING_STATUS_UNSPECIFIED SigningStatus = 0
	// SIGNING_STATUS_WAITING is the status of a signing that is waiting to be signed in the protocol.
	SIGNING_STATUS_WAITING SigningStatus = 1
	// SIGNING_STATUS_SUCCESS is the status of a signing that has success in the protocol.
	SIGNING_STATUS_SUCCESS SigningStatus = 2
	// SIGNING_STATUS_EXPIRED is the status of a signing that has expired in the protocol.
	SIGNING_STATUS_EXPIRED SigningStatus = 3
	// SIGNING_STATUS_FALLEN is the status of a signing that has fallen out of the protocol.
	SIGNING_STATUS_FALLEN SigningStatus = 4
)

var SigningStatus_name = map[int32]string{
	0: "SIGNING_STATUS_UNSPECIFIED",
	1: "SIGNING_STATUS_WAITING",
	2: "SIGNING_STATUS_SUCCESS",
	3: "SIGNING_STATUS_EXPIRED",
	4: "SIGNING_STATUS_FALLEN",
}

var SigningStatus_value = map[string]int32{
	"SIGNING_STATUS_UNSPECIFIED": 0,
	"SIGNING_STATUS_WAITING":     1,
	"SIGNING_STATUS_SUCCESS":     2,
	"SIGNING_STATUS_EXPIRED":     3,
	"SIGNING_STATUS_FALLEN":      4,
}

func (x SigningStatus) String() string {
	return proto.EnumName(SigningStatus_name, int32(x))
}

func (SigningStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}

// MemberStatus is an enumeration of the possible statuses of a member.
type MemberStatus int32

const (
	// MEMBER_STATUS_UNSPECIFIED is unknon status.
	MEMBER_STATUS_UNSPECIFIED MemberStatus = 0
	// MEMBER_STATUS_ACTIVE is the active status.
	MEMBER_STATUS_ACTIVE MemberStatus = 1
	// MEMBER_STATUS_INACTIVE is the inactive status.
	MEMBER_STATUS_INACTIVE MemberStatus = 2
	// MEMBER_STATUS_JAIL is the status when member is jailed.
	MEMBER_STATUS_JAIL MemberStatus = 3
)

var MemberStatus_name = map[int32]string{
	0: "MEMBER_STATUS_UNSPECIFIED",
	1: "MEMBER_STATUS_ACTIVE",
	2: "MEMBER_STATUS_INACTIVE",
	3: "MEMBER_STATUS_JAIL",
}

var MemberStatus_value = map[string]int32{
	"MEMBER_STATUS_UNSPECIFIED": 0,
	"MEMBER_STATUS_ACTIVE":      1,
	"MEMBER_STATUS_INACTIVE":    2,
	"MEMBER_STATUS_JAIL":        3,
}

func (x MemberStatus) String() string {
	return proto.EnumName(MemberStatus_name, int32(x))
}

func (MemberStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}

// GroupStatus is an enumeration of the possible statuses of a group.
type GroupStatus int32

const (
	// GROUP_STATUS_UNSPECIFIED is the status of a group that has not been specified.
	GROUP_STATUS_UNSPECIFIED GroupStatus = 0
	// GROUP_STATUS_ROUND_1 is the status of a group that is in the first round of the protocol.
	GROUP_STATUS_ROUND_1 GroupStatus = 1
	// GROUP_STATUS_ROUND_2 is the status of a group that is in the second round of the protocol.
	GROUP_STATUS_ROUND_2 GroupStatus = 2
	// GROUP_STATUS_ROUND_3 is the status of a group that is in the third round of the protocol.
	GROUP_STATUS_ROUND_3 GroupStatus = 3
	// GROUP_STATUS_ACTIVE is the status of a group that is actively participating in the protocol.
	GROUP_STATUS_ACTIVE GroupStatus = 4
	// GROUP_STATUS_EXPIRED is the status of a group that has expired in the protocol.
	GROUP_STATUS_EXPIRED GroupStatus = 5
	// GROUP_STATUS_FALLEN is the status of a group that has fallen out of the protocol.
	GROUP_STATUS_FALLEN GroupStatus = 6
)

var GroupStatus_name = map[int32]string{
	0: "GROUP_STATUS_UNSPECIFIED",
	1: "GROUP_STATUS_ROUND_1",
	2: "GROUP_STATUS_ROUND_2",
	3: "GROUP_STATUS_ROUND_3",
	4: "GROUP_STATUS_ACTIVE",
	5: "GROUP_STATUS_EXPIRED",
	6: "GROUP_STATUS_FALLEN",
}

var GroupStatus_value = map[string]int32{
	"GROUP_STATUS_UNSPECIFIED": 0,
	"GROUP_STATUS_ROUND_1":     1,
	"GROUP_STATUS_ROUND_2":     2,
	"GROUP_STATUS_ROUND_3":     3,
	"GROUP_STATUS_ACTIVE":      4,
	"GROUP_STATUS_EXPIRED":     5,
	"GROUP_STATUS_FALLEN":      6,
}

func (x GroupStatus) String() string {
	return proto.EnumName(GroupStatus_name, int32(x))
}

func (GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{2}
}

// ComplaintStatus represents the status of a complaint.
type ComplaintStatus int32

const (
	// COMPLAINT_STATUS_UNSPECIFIED represents an undefined status of the complaint.
	COMPLAINT_STATUS_UNSPECIFIED ComplaintStatus = 0
	// COMPLAINT_STATUS_SUCCESS represents a successful complaint.
	COMPLAINT_STATUS_SUCCESS ComplaintStatus = 1
	// COMPLAINT_STATUS_FAILED represents a failed complaint.
	COMPLAINT_STATUS_FAILED ComplaintStatus = 2
)

var ComplaintStatus_name = map[int32]string{
	0: "COMPLAINT_STATUS_UNSPECIFIED",
	1: "COMPLAINT_STATUS_SUCCESS",
	2: "COMPLAINT_STATUS_FAILED",
}

var ComplaintStatus_value = map[string]int32{
	"COMPLAINT_STATUS_UNSPECIFIED": 0,
	"COMPLAINT_STATUS_SUCCESS":     1,
	"COMPLAINT_STATUS_FAILED":      2,
}

func (x ComplaintStatus) String() string {
	return proto.EnumName(ComplaintStatus_name, int32(x))
}

func (ComplaintStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{3}
}

// Group is a type representing a participant group in a Distributed Key Generation or signing process.
type Group struct {
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// size is the number of members in the group.
	Size_ uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// threshold is the minimum number of members needed to generate a valid signature.
	Threshold uint64 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// pub_key is the public key generated by the group after successful completion of the DKG process.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// status represents the current stage of the group in the DKG or signing process.
	Status GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=tss.v1beta1.GroupStatus" json:"status,omitempty"`
	// fee is the tokens that will be paid per signing.
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	// created_height is the block height when the group was created.
	CreatedHeight int64 `protobuf:"varint,7,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Group) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Group) GetThreshold() uint64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *Group) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Group) GetStatus() GroupStatus {
	if m != nil {
		return m.Status
	}
	return GROUP_STATUS_UNSPECIFIED
}

func (m *Group) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *Group) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

// Round1Info contains all necessary information for handling round 1 of the DKG process.
type Round1Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// coefficients_commits is a list of commitments to the coefficients of the member's secret polynomial.
	CoefficientCommits github_com_bandprotocol_chain_v2_pkg_tss.Points `protobuf:"bytes,2,rep,name=coefficient_commits,json=coefficientCommits,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Points" json:"coefficient_commits,omitempty"`
	// one_time_pub_key is the one-time public key used by the member to encrypt secret shares.
	OneTimePubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=one_time_pub_key,json=oneTimePubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"one_time_pub_key,omitempty"`
	// a0_sig is the member's signature on the first coefficient of its secret polynomial.
	A0Sig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,4,opt,name=a0_sig,json=a0Sig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"a0_sig,omitempty"`
	// one_time_sig is the member's signature on its one-time public key.
	OneTimeSig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,5,opt,name=one_time_sig,json=oneTimeSig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"one_time_sig,omitempty"`
}

func (m *Round1Info) Reset()         { *m = Round1Info{} }
func (m *Round1Info) String() string { return proto.CompactTextString(m) }
func (*Round1Info) ProtoMessage()    {}
func (*Round1Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}
func (m *Round1Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round1Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round1Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round1Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round1Info.Merge(m, src)
}
func (m *Round1Info) XXX_Size() int {
	return m.Size()
}
func (m *Round1Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round1Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round1Info proto.InternalMessageInfo

func (m *Round1Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round1Info) GetCoefficientCommits() github_com_bandprotocol_chain_v2_pkg_tss.Points {
	if m != nil {
		return m.CoefficientCommits
	}
	return nil
}

func (m *Round1Info) GetOneTimePubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.OneTimePubKey
	}
	return nil
}

func (m *Round1Info) GetA0Sig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.A0Sig
	}
	return nil
}

func (m *Round1Info) GetOneTimeSig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OneTimeSig
	}
	return nil
}

// Round2Info contains all necessary information for handling round 2 of the DKG process.
type Round2Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// encrypted_secret_shares is a list of secret shares encrypted under the public keys of other members.
	EncryptedSecretShares github_com_bandprotocol_chain_v2_pkg_tss.Scalars `protobuf:"bytes,2,rep,name=encrypted_secret_shares,json=encryptedSecretShares,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Scalars" json:"encrypted_secret_shares,omitempty"`
}

func (m *Round2Info) Reset()         { *m = Round2Info{} }
func (m *Round2Info) String() string { return proto.CompactTextString(m) }
func (*Round2Info) ProtoMessage()    {}
func (*Round2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{2}
}
func (m *Round2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round2Info.Merge(m, src)
}
func (m *Round2Info) XXX_Size() int {
	return m.Size()
}
func (m *Round2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round2Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round2Info proto.InternalMessageInfo

func (m *Round2Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round2Info) GetEncryptedSecretShares() github_com_bandprotocol_chain_v2_pkg_tss.Scalars {
	if m != nil {
		return m.EncryptedSecretShares
	}
	return nil
}

// DE contains the public parts of a member's decryption and encryption keys.
type DE struct {
	// pub_d is the public value of own commitment (D).
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,1,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public value of own commitment (E).
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,2,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
}

func (m *DE) Reset()         { *m = DE{} }
func (m *DE) String() string { return proto.CompactTextString(m) }
func (*DE) ProtoMessage()    {}
func (*DE) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{3}
}
func (m *DE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DE.Merge(m, src)
}
func (m *DE) XXX_Size() int {
	return m.Size()
}
func (m *DE) XXX_DiscardUnknown() {
	xxx_messageInfo_DE.DiscardUnknown(m)
}

var xxx_messageInfo_DE proto.InternalMessageInfo

func (m *DE) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *DE) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

// DEQueue is a simple queue data structure for holding DE objects.
type DEQueue struct {
	// head is the index of the first element in the queue.
	Head uint64 `protobuf:"varint,1,opt,name=head,proto3" json:"head,omitempty"`
	// tail is the index of the last element in the queue.
	Tail uint64 `protobuf:"varint,2,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (m *DEQueue) Reset()         { *m = DEQueue{} }
func (m *DEQueue) String() string { return proto.CompactTextString(m) }
func (*DEQueue) ProtoMessage()    {}
func (*DEQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{4}
}
func (m *DEQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DEQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DEQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DEQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DEQueue.Merge(m, src)
}
func (m *DEQueue) XXX_Size() int {
	return m.Size()
}
func (m *DEQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_DEQueue.DiscardUnknown(m)
}

var xxx_messageInfo_DEQueue proto.InternalMessageInfo

func (m *DEQueue) GetHead() uint64 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *DEQueue) GetTail() uint64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

// Signing contains all necessary information for handling a signing request.
type Signing struct {
	// signing_id is the unique identifier of the signing process.
	SigningID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_id,omitempty"`
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// assigned_members is a list of members assigned to the signing process.
	AssignedMembers []AssignedMember `protobuf:"bytes,3,rep,name=assigned_members,json=assignedMembers,proto3" json:"assigned_members"`
	// message is the message to be signed.
	Message []byte `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// group_pub_nonce is the public nonce generated by the group for this signing process.
	GroupPubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,5,opt,name=group_pub_nonce,json=groupPubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"group_pub_nonce,omitempty"`
	// signature is the group's signature on the message.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,6,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
	// fee is the total tokens that will be paid for this signing
	Fee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=fee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"fee"`
	// status represents the current stage of the signing in the signing process.
	Status SigningStatus `protobuf:"varint,8,opt,name=status,proto3,enum=tss.v1beta1.SigningStatus" json:"status,omitempty"`
	// created_height is the block height when the signing was created.
	CreatedHeight int64 `protobuf:"varint,9,opt,name=created_height,json=createdHeight,proto3" json:"created_height,omitempty"`
	// request is the address of requester who paid for the TSS fee.
	Requester string `protobuf:"bytes,10,opt,name=requester,proto3" json:"requester,omitempty"`
}

func (m *Signing) Reset()         { *m = Signing{} }
func (m *Signing) String() string { return proto.CompactTextString(m) }
func (*Signing) ProtoMessage()    {}
func (*Signing) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{5}
}
func (m *Signing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signing.Merge(m, src)
}
func (m *Signing) XXX_Size() int {
	return m.Size()
}
func (m *Signing) XXX_DiscardUnknown() {
	xxx_messageInfo_Signing.DiscardUnknown(m)
}

var xxx_messageInfo_Signing proto.InternalMessageInfo

func (m *Signing) GetSigningID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningID
	}
	return 0
}

func (m *Signing) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Signing) GetAssignedMembers() []AssignedMember {
	if m != nil {
		return m.AssignedMembers
	}
	return nil
}

func (m *Signing) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Signing) GetGroupPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.GroupPubNonce
	}
	return nil
}

func (m *Signing) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signing) GetFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *Signing) GetStatus() SigningStatus {
	if m != nil {
		return m.Status
	}
	return SIGNING_STATUS_UNSPECIFIED
}

func (m *Signing) GetCreatedHeight() int64 {
	if m != nil {
		return m.CreatedHeight
	}
	return 0
}

func (m *Signing) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

// AssignedMember is a type representing a member that has been assigned to a signing process.
type AssignedMember struct {
	// member_id is the unique identifier of the member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// member is the human-readable name of the member.
	Member string `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	// pub_d is the public part of a member's decryption key.
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public part of a member's encryption key.
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
	// binding_factor is the binding factor of the member for the signing process.
	BindingFactor []byte `protobuf:"bytes,5,opt,name=binding_factor,json=bindingFactor,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Scalar" json:"binding_factor,omitempty"`
	// pub_nonce is the public nonce of the member for the signing process.
	PubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,6,opt,name=pub_nonce,json=pubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_nonce,omitempty"`
}

func (m *AssignedMember) Reset()         { *m = AssignedMember{} }
func (m *AssignedMember) String() string { return proto.CompactTextString(m) }
func (*AssignedMember) ProtoMessage()    {}
func (*AssignedMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{6}
}
func (m *AssignedMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedMember.Merge(m, src)
}
func (m *AssignedMember) XXX_Size() int {
	return m.Size()
}
func (m *AssignedMember) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedMember.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedMember proto.InternalMessageInfo

func (m *AssignedMember) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *AssignedMember) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

func (m *AssignedMember) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *AssignedMember) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

func (m *AssignedMember) GetBindingFactor() []byte {
	if m != nil {
		return m.BindingFactor
	}
	return nil
}

func (m *AssignedMember) GetPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubNonce
	}
	return nil
}

// PendingSignings is a list of all signing processes that are currently pending.
type PendingSignings struct {
	// signing_ids is a list of identifiers for the signing processes.
	SigningIds []uint64 `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3" json:"signing_ids,omitempty"`
}

func (m *PendingSignings) Reset()         { *m = PendingSignings{} }
func (m *PendingSignings) String() string { return proto.CompactTextString(m) }
func (*PendingSignings) ProtoMessage()    {}
func (*PendingSignings) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{7}
}
func (m *PendingSignings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingSignings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingSignings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingSignings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingSignings.Merge(m, src)
}
func (m *PendingSignings) XXX_Size() int {
	return m.Size()
}
func (m *PendingSignings) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingSignings.DiscardUnknown(m)
}

var xxx_messageInfo_PendingSignings proto.InternalMessageInfo

func (m *PendingSignings) GetSigningIds() []uint64 {
	if m != nil {
		return m.SigningIds
	}
	return nil
}

// Member is a type representing a member of the group.
type Member struct {
	// id is the unique identifier of a member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"id,omitempty"`
	// address is the address of the member.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public key of the member.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// is_malicious is a boolean flag indicating whether the member is considered malicious.
	IsMalicious bool `protobuf:"varint,4,opt,name=is_malicious,json=isMalicious,proto3" json:"is_malicious,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{8}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Member) GetIsMalicious() bool {
	if m != nil {
		return m.IsMalicious
	}
	return false
}

// Status maintains whether a member is an active member.
type Status struct {
	// address is the address of the member.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// status represents the current status of the member
	Status MemberStatus `protobuf:"varint,2,opt,name=status,proto3,enum=tss.v1beta1.MemberStatus" json:"status,omitempty"`
	// since is a block timestamp when a member has been activated/deactivated/jailed
	Since time.Time `protobuf:"bytes,3,opt,name=since,proto3,stdtime" json:"since"`
	// last_active is a latest block timestamp when a member is active
	LastActive time.Time `protobuf:"bytes,4,opt,name=last_active,json=lastActive,proto3,stdtime" json:"last_active"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{9}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Status) GetStatus() MemberStatus {
	if m != nil {
		return m.Status
	}
	return MEMBER_STATUS_UNSPECIFIED
}

func (m *Status) GetSince() time.Time {
	if m != nil {
		return m.Since
	}
	return time.Time{}
}

func (m *Status) GetLastActive() time.Time {
	if m != nil {
		return m.LastActive
	}
	return time.Time{}
}

// Confirm is a message type used to confirm participation in the protocol.
type Confirm struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// own_pub_key_sig is a signature over the member's own public key.
	OwnPubKeySig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=own_pub_key_sig,json=ownPubKeySig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"own_pub_key_sig,omitempty"`
}

func (m *Confirm) Reset()         { *m = Confirm{} }
func (m *Confirm) String() string { return proto.CompactTextString(m) }
func (*Confirm) ProtoMessage()    {}
func (*Confirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{10}
}
func (m *Confirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Confirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Confirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Confirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Confirm.Merge(m, src)
}
func (m *Confirm) XXX_Size() int {
	return m.Size()
}
func (m *Confirm) XXX_DiscardUnknown() {
	xxx_messageInfo_Confirm.DiscardUnknown(m)
}

var xxx_messageInfo_Confirm proto.InternalMessageInfo

func (m *Confirm) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Confirm) GetOwnPubKeySig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OwnPubKeySig
	}
	return nil
}

// Complaint is a message type used to issue a complaint against a member.
type Complaint struct {
	// complainant is the member issuing the complaint.
	Complainant github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=complainant,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"complainant,omitempty"`
	// respondent is the member against whom the complaint is issued.
	Respondent github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,2,opt,name=respondent,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"respondent,omitempty"`
	// key_sym is a symmetric key between respondent's private key and respondent's public key.
	KeySym github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=key_sym,json=keySym,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"key_sym,omitempty"`
	// signature is the complaint signature that can do a symmetric key validation and complaint verification.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature `protobuf:"bytes,4,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.ComplaintSignature" json:"signature,omitempty"`
}

func (m *Complaint) Reset()         { *m = Complaint{} }
func (m *Complaint) String() string { return proto.CompactTextString(m) }
func (*Complaint) ProtoMessage()    {}
func (*Complaint) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{11}
}
func (m *Complaint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Complaint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Complaint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Complaint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Complaint.Merge(m, src)
}
func (m *Complaint) XXX_Size() int {
	return m.Size()
}
func (m *Complaint) XXX_DiscardUnknown() {
	xxx_messageInfo_Complaint.DiscardUnknown(m)
}

var xxx_messageInfo_Complaint proto.InternalMessageInfo

func (m *Complaint) GetComplainant() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Complainant
	}
	return 0
}

func (m *Complaint) GetRespondent() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Respondent
	}
	return 0
}

func (m *Complaint) GetKeySym() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.KeySym
	}
	return nil
}

func (m *Complaint) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// ComplaintWithStatus contains information about a complaint with its status.
type ComplaintWithStatus struct {
	// complaint is the information about the complaint.
	Complaint Complaint `protobuf:"bytes,1,opt,name=complaint,proto3" json:"complaint"`
	// complaint_status is the status of the complaint.
	ComplaintStatus ComplaintStatus `protobuf:"varint,2,opt,name=complaint_status,json=complaintStatus,proto3,enum=tss.v1beta1.ComplaintStatus" json:"complaint_status,omitempty"`
}

func (m *ComplaintWithStatus) Reset()         { *m = ComplaintWithStatus{} }
func (m *ComplaintWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintWithStatus) ProtoMessage()    {}
func (*ComplaintWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{12}
}
func (m *ComplaintWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintWithStatus.Merge(m, src)
}
func (m *ComplaintWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintWithStatus proto.InternalMessageInfo

func (m *ComplaintWithStatus) GetComplaint() Complaint {
	if m != nil {
		return m.Complaint
	}
	return Complaint{}
}

func (m *ComplaintWithStatus) GetComplaintStatus() ComplaintStatus {
	if m != nil {
		return m.ComplaintStatus
	}
	return COMPLAINT_STATUS_UNSPECIFIED
}

// ComplaintsWithStatus contains information about multiple complaints and their status from a single member.
type ComplaintsWithStatus struct {
	// member_id is the identifier of the member filing the complaints.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// complaints_with_status is the list of complaints with their status from this member.
	ComplaintsWithStatus []ComplaintWithStatus `protobuf:"bytes,2,rep,name=complaints_with_status,json=complaintsWithStatus,proto3" json:"complaints_with_status"`
}

func (m *ComplaintsWithStatus) Reset()         { *m = ComplaintsWithStatus{} }
func (m *ComplaintsWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintsWithStatus) ProtoMessage()    {}
func (*ComplaintsWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{13}
}
func (m *ComplaintsWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintsWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintsWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintsWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintsWithStatus.Merge(m, src)
}
func (m *ComplaintsWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintsWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintsWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintsWithStatus proto.InternalMessageInfo

func (m *ComplaintsWithStatus) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *ComplaintsWithStatus) GetComplaintsWithStatus() []ComplaintWithStatus {
	if m != nil {
		return m.ComplaintsWithStatus
	}
	return nil
}

// PendingProcessGroups is a list of groups that are waiting to be processed.
type PendingProcessGroups struct {
	// signing_id is a list of group IDs.
	GroupIDs []github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,rep,packed,name=group_ids,json=groupIds,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_ids,omitempty"`
}

func (m *PendingProcessGroups) Reset()         { *m = PendingProcessGroups{} }
func (m *PendingProcessGroups) String() string { return proto.CompactTextString(m) }
func (*PendingProcessGroups) ProtoMessage()    {}
func (*PendingProcessGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{14}
}
func (m *PendingProcessGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingProcessGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingProcessGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingProcessGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingProcessGroups.Merge(m, src)
}
func (m *PendingProcessGroups) XXX_Size() int {
	return m.Size()
}
func (m *PendingProcessGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingProcessGroups.DiscardUnknown(m)
}

var xxx_messageInfo_PendingProcessGroups proto.InternalMessageInfo

func (m *PendingProcessGroups) GetGroupIDs() []github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupIDs
	}
	return nil
}

// PendingProcessSignigns is a list of signings that are waiting to be processed.
type PendingProcessSignings struct {
	// signing_id is a list of signing IDs.
	SigningIDs []github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_ids,omitempty"`
}

func (m *PendingProcessSignings) Reset()         { *m = PendingProcessSignings{} }
func (m *PendingProcessSignings) String() string { return proto.CompactTextString(m) }
func (*PendingProcessSignings) ProtoMessage()    {}
func (*PendingProcessSignings) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{15}
}
func (m *PendingProcessSignings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingProcessSignings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingProcessSignings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingProcessSignings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingProcessSignings.Merge(m, src)
}
func (m *PendingProcessSignings) XXX_Size() int {
	return m.Size()
}
func (m *PendingProcessSignings) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingProcessSignings.DiscardUnknown(m)
}

var xxx_messageInfo_PendingProcessSignings proto.InternalMessageInfo

func (m *PendingProcessSignings) GetSigningIDs() []github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningIDs
	}
	return nil
}

// PendingReplaceGroup represents a group replacement operation.
type PendingReplaceGroup struct {
	// signing_id is the unique identifier of the signing process.
	SigningID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_id,omitempty"`
	// from_group_id is the ID of the group that want to replace, and subsequently remove this group.
	FromGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=from_group_id,json=fromGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"from_group_id,omitempty"`
	// to_group_id is the ID of the group that will take the place of another group.
	ToGroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,3,opt,name=to_group_id,json=toGroupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"to_group_id,omitempty"`
	// exec_time is the time that will be substituted in place of the group.
	ExecTime time.Time `protobuf:"bytes,4,opt,name=exec_time,json=execTime,proto3,stdtime" json:"exec_time"`
}

func (m *PendingReplaceGroup) Reset()         { *m = PendingReplaceGroup{} }
func (m *PendingReplaceGroup) String() string { return proto.CompactTextString(m) }
func (*PendingReplaceGroup) ProtoMessage()    {}
func (*PendingReplaceGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{16}
}
func (m *PendingReplaceGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingReplaceGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingReplaceGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingReplaceGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingReplaceGroup.Merge(m, src)
}
func (m *PendingReplaceGroup) XXX_Size() int {
	return m.Size()
}
func (m *PendingReplaceGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingReplaceGroup.DiscardUnknown(m)
}

var xxx_messageInfo_PendingReplaceGroup proto.InternalMessageInfo

func (m *PendingReplaceGroup) GetSigningID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningID
	}
	return 0
}

func (m *PendingReplaceGroup) GetFromGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.FromGroupID
	}
	return 0
}

func (m *PendingReplaceGroup) GetToGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.ToGroupID
	}
	return 0
}

func (m *PendingReplaceGroup) GetExecTime() time.Time {
	if m != nil {
		return m.ExecTime
	}
	return time.Time{}
}

// PendingReplaceGroups is a list of groups that are waiting to be replaced.
type PendingReplaceGroups struct {
	// pending_replace_groups is a list of pending replace group.
	PendingReplaceGroups []PendingReplaceGroup `protobuf:"bytes,1,rep,name=pending_replace_groups,json=pendingReplaceGroups,proto3" json:"pending_replace_groups"`
}

func (m *PendingReplaceGroups) Reset()         { *m = PendingReplaceGroups{} }
func (m *PendingReplaceGroups) String() string { return proto.CompactTextString(m) }
func (*PendingReplaceGroups) ProtoMessage()    {}
func (*PendingReplaceGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{17}
}
func (m *PendingReplaceGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingReplaceGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingReplaceGroups.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingReplaceGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingReplaceGroups.Merge(m, src)
}
func (m *PendingReplaceGroups) XXX_Size() int {
	return m.Size()
}
func (m *PendingReplaceGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingReplaceGroups.DiscardUnknown(m)
}

var xxx_messageInfo_PendingReplaceGroups proto.InternalMessageInfo

func (m *PendingReplaceGroups) GetPendingReplaceGroups() []PendingReplaceGroup {
	if m != nil {
		return m.PendingReplaceGroups
	}
	return nil
}

// PartialSignature contains information about a member's partial signature.
type PartialSignature struct {
	// member_id is the identifier of the member providing the partial signature.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// signature is the partial signature provided by this member.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
}

func (m *PartialSignature) Reset()         { *m = PartialSignature{} }
func (m *PartialSignature) String() string { return proto.CompactTextString(m) }
func (*PartialSignature) ProtoMessage()    {}
func (*PartialSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{18}
}
func (m *PartialSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartialSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartialSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialSignature.Merge(m, src)
}
func (m *PartialSignature) XXX_Size() int {
	return m.Size()
}
func (m *PartialSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialSignature.DiscardUnknown(m)
}

var xxx_messageInfo_PartialSignature proto.InternalMessageInfo

func (m *PartialSignature) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *PartialSignature) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// TextRequestSignature defines a standard request signature.
type TextRequestSignature struct {
	// message is the data that needs to be signed.
	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TextRequestSignature) Reset()         { *m = TextRequestSignature{} }
func (m *TextRequestSignature) String() string { return proto.CompactTextString(m) }
func (*TextRequestSignature) ProtoMessage()    {}
func (*TextRequestSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{19}
}
func (m *TextRequestSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextRequestSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextRequestSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextRequestSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextRequestSignature.Merge(m, src)
}
func (m *TextRequestSignature) XXX_Size() int {
	return m.Size()
}
func (m *TextRequestSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_TextRequestSignature.DiscardUnknown(m)
}

var xxx_messageInfo_TextRequestSignature proto.InternalMessageInfo

func (m *TextRequestSignature) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func init() {
	proto.RegisterEnum("tss.v1beta1.SigningStatus", SigningStatus_name, SigningStatus_value)
	proto.RegisterEnum("tss.v1beta1.MemberStatus", MemberStatus_name, MemberStatus_value)
	proto.RegisterEnum("tss.v1beta1.GroupStatus", GroupStatus_name, GroupStatus_value)
	proto.RegisterEnum("tss.v1beta1.ComplaintStatus", ComplaintStatus_name, ComplaintStatus_value)
	proto.RegisterType((*Group)(nil), "tss.v1beta1.Group")
	proto.RegisterType((*Round1Info)(nil), "tss.v1beta1.Round1Info")
	proto.RegisterType((*Round2Info)(nil), "tss.v1beta1.Round2Info")
	proto.RegisterType((*DE)(nil), "tss.v1beta1.DE")
	proto.RegisterType((*DEQueue)(nil), "tss.v1beta1.DEQueue")
	proto.RegisterType((*Signing)(nil), "tss.v1beta1.Signing")
	proto.RegisterType((*AssignedMember)(nil), "tss.v1beta1.AssignedMember")
	proto.RegisterType((*PendingSignings)(nil), "tss.v1beta1.PendingSignings")
	proto.RegisterType((*Member)(nil), "tss.v1beta1.Member")
	proto.RegisterType((*Status)(nil), "tss.v1beta1.Status")
	proto.RegisterType((*Confirm)(nil), "tss.v1beta1.Confirm")
	proto.RegisterType((*Complaint)(nil), "tss.v1beta1.Complaint")
	proto.RegisterType((*ComplaintWithStatus)(nil), "tss.v1beta1.ComplaintWithStatus")
	proto.RegisterType((*ComplaintsWithStatus)(nil), "tss.v1beta1.ComplaintsWithStatus")
	proto.RegisterType((*PendingProcessGroups)(nil), "tss.v1beta1.PendingProcessGroups")
	proto.RegisterType((*PendingProcessSignings)(nil), "tss.v1beta1.PendingProcessSignings")
	proto.RegisterType((*PendingReplaceGroup)(nil), "tss.v1beta1.PendingReplaceGroup")
	proto.RegisterType((*PendingReplaceGroups)(nil), "tss.v1beta1.PendingReplaceGroups")
	proto.RegisterType((*PartialSignature)(nil), "tss.v1beta1.PartialSignature")
	proto.RegisterType((*TextRequestSignature)(nil), "tss.v1beta1.TextRequestSignature")
}

func init() { proto.RegisterFile("tss/v1beta1/tss.proto", fileDescriptor_321be6f53cb0491e) }

var fileDescriptor_321be6f53cb0491e = []byte{
	// 1771 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x3f, 0x6f, 0x1b, 0xc9,
	0x15, 0xd7, 0x72, 0x29, 0x8a, 0x7c, 0x94, 0x2c, 0x62, 0x2c, 0xcb, 0x94, 0x4e, 0x21, 0x19, 0x02,
	0x01, 0x88, 0x43, 0x4e, 0x94, 0xe8, 0x24, 0x85, 0x83, 0xe0, 0xc2, 0x7f, 0x52, 0x78, 0x27, 0xd1,
	0xbc, 0x25, 0x15, 0x1f, 0x9c, 0x38, 0x8b, 0xe5, 0x72, 0x48, 0x2e, 0x4c, 0xee, 0x30, 0x3b, 0x43,
	0xdb, 0x4a, 0x13, 0xa4, 0xbb, 0xf2, 0xaa, 0x14, 0x57, 0x05, 0x48, 0x8a, 0xc0, 0x75, 0xba, 0x7c,
	0x80, 0x18, 0x49, 0x73, 0x45, 0x8a, 0x43, 0x0a, 0x3a, 0x90, 0x11, 0x24, 0x9f, 0xc1, 0x55, 0x30,
	0x3b, 0xb3, 0x4b, 0xae, 0x44, 0xe3, 0x24, 0xca, 0x72, 0xc5, 0xd9, 0x79, 0xf3, 0x7e, 0xf3, 0xfe,
	0xbf, 0x37, 0x84, 0x3b, 0x8c, 0xd2, 0xfc, 0xd3, 0xfd, 0x36, 0x66, 0xc6, 0x7e, 0x9e, 0x51, 0xba,
	0x3b, 0x72, 0x08, 0x23, 0x28, 0xce, 0x97, 0x72, 0x7b, 0x7b, 0xa3, 0x47, 0x7a, 0xc4, 0xdd, 0xcf,
	0xf3, 0x95, 0x38, 0xb2, 0x9d, 0xee, 0x11, 0xd2, 0x1b, 0xe0, 0xbc, 0xfb, 0xd5, 0x1e, 0x77, 0xf3,
	0xcc, 0x1a, 0x62, 0xca, 0x8c, 0xe1, 0x48, 0x1e, 0x48, 0x99, 0x84, 0x0e, 0x09, 0xcd, 0xb7, 0x0d,
	0x8a, 0xfd, 0x2b, 0x4c, 0x62, 0xd9, 0x92, 0xbe, 0x25, 0xe8, 0xba, 0x40, 0x16, 0x1f, 0x82, 0x94,
	0xfd, 0x4a, 0x85, 0xe5, 0x43, 0x87, 0x8c, 0x47, 0xe8, 0x11, 0x44, 0x7b, 0x7c, 0xa1, 0x5b, 0x9d,
	0xa4, 0x92, 0x51, 0x72, 0xe1, 0xd2, 0xc7, 0x67, 0x93, 0xf4, 0x8a, 0x4b, 0xac, 0x55, 0xde, 0x4c,
	0xd2, 0x7b, 0x3d, 0x8b, 0xf5, 0xc7, 0xed, 0x5d, 0x93, 0x0c, 0xf3, 0x6d, 0xc3, 0xee, 0xb8, 0x00,
	0x26, 0x19, 0xe4, 0xcd, 0xbe, 0x61, 0xd9, 0xf9, 0xa7, 0x85, 0xfc, 0xe8, 0x49, 0xcf, 0xd5, 0x4c,
	0xf2, 0x68, 0x2b, 0x2e, 0x60, 0xad, 0x83, 0x10, 0x84, 0xa9, 0xf5, 0x1b, 0x9c, 0x0c, 0x71, 0x5c,
	0xcd, 0x5d, 0xa3, 0x1d, 0x88, 0xb1, 0xbe, 0x83, 0x69, 0x9f, 0x0c, 0x3a, 0x49, 0xd5, 0x25, 0x4c,
	0x37, 0xd0, 0xa7, 0xb0, 0x32, 0x1a, 0xb7, 0xf5, 0x27, 0xf8, 0x34, 0x19, 0xce, 0x28, 0xb9, 0xd5,
	0x52, 0xe1, 0xcd, 0x24, 0xbd, 0x7b, 0x69, 0x09, 0x1a, 0xc4, 0xb2, 0x99, 0x16, 0x19, 0x8d, 0xdb,
	0x9f, 0xe2, 0x53, 0xb4, 0x07, 0x11, 0xca, 0x0c, 0x36, 0xa6, 0xc9, 0xe5, 0x8c, 0x92, 0xbb, 0x55,
	0x48, 0xee, 0xce, 0x18, 0x5d, 0x48, 0xdb, 0x74, 0xe9, 0x9a, 0x3c, 0x87, 0x1e, 0x83, 0xda, 0xc5,
	0x38, 0x19, 0xc9, 0xa8, 0xb9, 0x78, 0x61, 0x6b, 0x57, 0x9a, 0x8c, 0xdb, 0xd7, 0x67, 0x2b, 0x13,
	0xcb, 0x2e, 0xed, 0xbd, 0x9c, 0xa4, 0x97, 0x5e, 0xbc, 0x4a, 0xe7, 0x66, 0x24, 0x93, 0xce, 0x10,
	0x3f, 0x1f, 0xd1, 0xce, 0x93, 0x3c, 0x3b, 0x1d, 0x61, 0xea, 0x32, 0x50, 0x8d, 0xe3, 0xa2, 0xef,
	0xc1, 0x2d, 0xd3, 0xc1, 0x06, 0xc3, 0x1d, 0xbd, 0x8f, 0xad, 0x5e, 0x9f, 0x25, 0x57, 0x32, 0x4a,
	0x4e, 0xd5, 0xd6, 0xe4, 0xee, 0xcf, 0xdc, 0xcd, 0xec, 0x37, 0x2a, 0x80, 0x46, 0xc6, 0x76, 0x67,
	0xbf, 0x66, 0x77, 0x09, 0xfa, 0x15, 0xc4, 0x86, 0x78, 0xd8, 0xc6, 0xce, 0xd4, 0x45, 0xc5, 0xb3,
	0x49, 0x3a, 0x7a, 0xec, 0x6e, 0xba, 0x3e, 0xda, 0xbf, 0xb4, 0x85, 0x3c, 0x26, 0x2d, 0x2a, 0x30,
	0x6b, 0x1d, 0xd4, 0x81, 0xdb, 0x26, 0xc1, 0xdd, 0xae, 0x65, 0x5a, 0xd8, 0x66, 0xba, 0x49, 0x86,
	0x43, 0x8b, 0xd1, 0x64, 0x28, 0xa3, 0xe6, 0x56, 0x4b, 0xf7, 0x5e, 0xbc, 0x4a, 0xe7, 0xaf, 0x66,
	0x7f, 0xaa, 0xa1, 0x19, 0xbc, 0xb2, 0x80, 0x43, 0xbf, 0x80, 0x04, 0xb1, 0xb1, 0xce, 0x63, 0x58,
	0xf7, 0x5c, 0xac, 0x2e, 0xec, 0xe2, 0x35, 0x62, 0xe3, 0x96, 0x35, 0xc4, 0x0d, 0xe1, 0xe9, 0x63,
	0x88, 0x18, 0x7b, 0x3a, 0xb5, 0x7a, 0x32, 0x6a, 0x7e, 0xf4, 0x66, 0x92, 0x2e, 0x5c, 0x1a, 0xb2,
	0x69, 0xf5, 0x6c, 0x83, 0x8d, 0x1d, 0xac, 0x2d, 0x1b, 0x7b, 0x4d, 0xab, 0x87, 0x3e, 0x87, 0x55,
	0x5f, 0x56, 0x0e, 0xba, 0x7c, 0x2d, 0x50, 0x90, 0xb2, 0x36, 0xad, 0x5e, 0xf6, 0x5f, 0x8a, 0x74,
	0x6d, 0xe1, 0xbd, 0xb8, 0x76, 0x00, 0x77, 0xb1, 0x6d, 0x3a, 0xa7, 0x23, 0x1e, 0x72, 0x14, 0x9b,
	0x0e, 0x66, 0x3a, 0xed, 0x1b, 0x0e, 0xf6, 0xdc, 0xfb, 0x83, 0x17, 0xaf, 0xae, 0x90, 0xe0, 0x4d,
	0xd3, 0x18, 0x18, 0x0e, 0xd5, 0xee, 0xf8, 0xa0, 0x4d, 0x17, 0xb3, 0xe9, 0x42, 0x66, 0x7f, 0xaf,
	0x40, 0xa8, 0x52, 0x45, 0x87, 0xb0, 0xcc, 0x1d, 0x2c, 0x14, 0x5a, 0xcc, 0xbd, 0xe1, 0xd1, 0xb8,
	0x5d, 0xf1, 0x80, 0x44, 0xfd, 0x58, 0x1c, 0xa8, 0x9a, 0xdd, 0x87, 0x95, 0x4a, 0xf5, 0xb3, 0x31,
	0x1e, 0x63, 0x5e, 0x92, 0xfa, 0xd8, 0x90, 0xc6, 0xd6, 0xdc, 0x35, 0xdf, 0x63, 0x86, 0x35, 0xf0,
	0xca, 0x14, 0x5f, 0x67, 0xff, 0xba, 0x0c, 0x2b, 0xdc, 0x85, 0x96, 0xdd, 0x43, 0x6d, 0x00, 0x2a,
	0x96, 0x53, 0x37, 0x95, 0xcf, 0x26, 0xe9, 0x98, 0x3c, 0xe0, 0xfa, 0xe9, 0x6a, 0x91, 0xe1, 0x72,
	0x69, 0x31, 0x09, 0x5b, 0xeb, 0x04, 0xca, 0x70, 0xe8, 0x1d, 0x97, 0xe1, 0x23, 0x48, 0x18, 0x94,
	0x5f, 0x85, 0x3b, 0xba, 0x08, 0x0d, 0x9a, 0x54, 0xdd, 0x12, 0xf7, 0x41, 0xa0, 0x22, 0x16, 0xe5,
	0x21, 0x11, 0x48, 0xa5, 0x30, 0x2f, 0x72, 0xda, 0xba, 0x11, 0xd8, 0xa5, 0x28, 0x09, 0x2b, 0x43,
	0x4c, 0xa9, 0xd1, 0xc3, 0x22, 0xd9, 0x34, 0xef, 0x13, 0x3d, 0x82, 0x75, 0xa1, 0x03, 0xf7, 0x9a,
	0x4d, 0x6c, 0x13, 0xcb, 0xcc, 0x59, 0x28, 0xc3, 0x5d, 0xa8, 0xc6, 0xb8, 0x5d, 0xe7, 0x40, 0xa8,
	0x05, 0xae, 0xb1, 0xdc, 0x8c, 0x4a, 0x46, 0xae, 0x95, 0x8f, 0x53, 0x20, 0xaf, 0xde, 0xaf, 0xdc,
	0x50, 0xbd, 0x2f, 0xf8, 0x0d, 0x28, 0xea, 0x36, 0xa0, 0xed, 0x80, 0xb9, 0x65, 0x1c, 0x9c, 0x6b,
	0x41, 0x17, 0x7b, 0x44, 0x6c, 0x4e, 0x8f, 0xe0, 0x6d, 0xd4, 0xc1, 0xbf, 0x1e, 0x63, 0xca, 0xb0,
	0x93, 0x84, 0x8c, 0x92, 0x8b, 0x69, 0xd3, 0x8d, 0xec, 0xdf, 0x54, 0xb8, 0x15, 0xf4, 0xe6, 0x8d,
	0x97, 0x9a, 0x4d, 0x88, 0x88, 0xb5, 0x1b, 0xbe, 0x31, 0x4d, 0x7e, 0x4d, 0xab, 0x81, 0xfa, 0xae,
	0xaa, 0x41, 0xf8, 0x7a, 0xd5, 0x00, 0x3d, 0x82, 0x5b, 0x6d, 0xcb, 0xee, 0xf0, 0x74, 0xee, 0x1a,
	0x26, 0x23, 0x8e, 0x8c, 0xd2, 0xab, 0xb5, 0x3a, 0x51, 0x0b, 0xb5, 0x35, 0x09, 0x75, 0xe0, 0x22,
	0xa1, 0x07, 0x10, 0x9b, 0x06, 0x7f, 0x64, 0x61, 0x41, 0xa3, 0x23, 0x19, 0xf7, 0xd9, 0x02, 0xac,
	0x37, 0xb0, 0x7b, 0x83, 0x0c, 0x17, 0x8a, 0xd2, 0x10, 0x9f, 0x96, 0x23, 0x9a, 0x54, 0x32, 0x6a,
	0x2e, 0xac, 0x81, 0x5f, 0x4a, 0x68, 0xf6, 0x3f, 0x0a, 0x44, 0xa4, 0xd7, 0x3f, 0x83, 0xd0, 0xbb,
	0x74, 0x77, 0xc8, 0xea, 0xf0, 0xfc, 0x37, 0x3a, 0x1d, 0x07, 0x53, 0x2a, 0x3d, 0xed, 0x7d, 0xce,
	0x0e, 0x6f, 0xea, 0xb5, 0x87, 0xb7, 0xef, 0xc2, 0xaa, 0x45, 0xf5, 0xa1, 0x31, 0xb0, 0x4c, 0x8b,
	0x8c, 0xa9, 0xeb, 0xf5, 0xa8, 0x16, 0xb7, 0xe8, 0xb1, 0xb7, 0x95, 0x9d, 0x28, 0x10, 0x11, 0xd9,
	0x33, 0x2b, 0x94, 0x12, 0x14, 0x6a, 0xdf, 0xcf, 0xc1, 0x90, 0x9b, 0x83, 0x5b, 0x81, 0x1c, 0x14,
	0x9a, 0x9d, 0x4b, 0xc1, 0xfb, 0xb0, 0x4c, 0x2d, 0xee, 0x40, 0xae, 0x45, 0xbc, 0xb0, 0xbd, 0x2b,
	0x06, 0xf1, 0x5d, 0x6f, 0x10, 0xdf, 0x6d, 0x79, 0x83, 0x78, 0x29, 0xca, 0x0b, 0xc3, 0x97, 0xaf,
	0xd2, 0x8a, 0x26, 0x58, 0x50, 0x15, 0xe2, 0x03, 0x83, 0x32, 0xdd, 0x30, 0x99, 0xf5, 0x54, 0xc4,
	0xea, 0x65, 0x11, 0x80, 0x33, 0x16, 0x5d, 0xbe, 0xfb, 0xe1, 0xff, 0xfd, 0x21, 0xad, 0x64, 0x5f,
	0x2a, 0xb0, 0x52, 0x26, 0x76, 0xd7, 0x72, 0x86, 0x37, 0x9e, 0xbf, 0x8f, 0x61, 0x9d, 0x3c, 0xb3,
	0xbd, 0xd1, 0xcc, 0x1d, 0x7b, 0x42, 0xd7, 0x2a, 0xb3, 0xab, 0xe4, 0x99, 0x2d, 0xc6, 0x33, 0x3e,
	0xf8, 0xfc, 0x37, 0x04, 0xb1, 0x32, 0x19, 0x8e, 0x06, 0x86, 0x65, 0x33, 0xf4, 0x10, 0xe2, 0xa6,
	0xfc, 0x30, 0x6c, 0x26, 0xd5, 0xf9, 0xe1, 0x62, 0x2a, 0xcc, 0x22, 0xa1, 0x13, 0x00, 0x07, 0xd3,
	0x11, 0xb1, 0x3b, 0xd8, 0x66, 0xb2, 0x91, 0x2e, 0x88, 0x3b, 0x03, 0xc4, 0x23, 0xdb, 0x35, 0xca,
	0xe9, 0xf0, 0x3a, 0x91, 0xfd, 0x04, 0x9f, 0x36, 0x4f, 0x87, 0xe8, 0xf1, 0x6c, 0x2b, 0x13, 0xc5,
	0xec, 0xe3, 0x37, 0x93, 0xf4, 0x8f, 0x2f, 0x0d, 0xe7, 0xdb, 0x71, 0x5e, 0x4f, 0xcb, 0x7e, 0xa5,
	0xc0, 0x6d, 0xff, 0xc4, 0x43, 0x8b, 0xf5, 0x9b, 0x5e, 0x54, 0xc7, 0x3c, 0x4b, 0x09, 0x8b, 0xc7,
	0x0b, 0x9b, 0x81, 0x5c, 0xf0, 0x99, 0x64, 0xe7, 0x9f, 0x1e, 0x47, 0x87, 0x90, 0xf0, 0x3f, 0xf4,
	0x40, 0x3a, 0xed, 0xcc, 0x87, 0x90, 0x19, 0xb5, 0x6e, 0x06, 0x37, 0xb2, 0xff, 0x54, 0x60, 0xc3,
	0x3f, 0x44, 0x67, 0xa4, 0xbb, 0xe9, 0xf0, 0xfe, 0x25, 0x6c, 0xfa, 0xb2, 0x50, 0xfd, 0x99, 0xc5,
	0xfa, 0x53, 0x3d, 0x78, 0xf3, 0xcf, 0xcc, 0xd7, 0x63, 0x2a, 0xa1, 0x34, 0xca, 0x86, 0x39, 0x47,
	0xfa, 0xec, 0x18, 0x36, 0x64, 0x95, 0x6e, 0x38, 0xc4, 0xc4, 0x94, 0xba, 0x33, 0x18, 0x7f, 0x4f,
	0xc6, 0xbc, 0xa9, 0x4e, 0x16, 0xea, 0xd2, 0x4f, 0xb9, 0x56, 0x72, 0x44, 0xa3, 0x0b, 0xcd, 0x75,
	0x51, 0x39, 0xd7, 0xd1, 0xec, 0x6f, 0x61, 0x33, 0x78, 0xad, 0xdf, 0x23, 0xf0, 0x9c, 0x1e, 0x51,
	0xaa, 0x9c, 0x4d, 0xd2, 0xe0, 0x4f, 0x9f, 0x74, 0xc1, 0xa1, 0x75, 0xb6, 0xd3, 0x7c, 0xa1, 0xc2,
	0x6d, 0x29, 0x81, 0x86, 0x47, 0x03, 0xc3, 0xc4, 0xe2, 0x4f, 0x85, 0xf7, 0x31, 0x31, 0xf7, 0x60,
	0xad, 0xeb, 0x90, 0xa1, 0x7e, 0x6e, 0x6c, 0xe6, 0xd7, 0xc4, 0x0f, 0x1c, 0x32, 0xbc, 0xce, 0xe8,
	0x1c, 0xef, 0xfa, 0x00, 0x1d, 0x64, 0x40, 0x9c, 0x91, 0xe9, 0x35, 0xaa, 0x1f, 0x9c, 0xb1, 0x16,
	0xb9, 0xce, 0x25, 0x31, 0x46, 0xbc, 0x2b, 0x8a, 0x10, 0xc3, 0xcf, 0xb1, 0xe9, 0xbe, 0x38, 0xaf,
	0xd4, 0x33, 0xa2, 0x9c, 0x8d, 0x13, 0xb2, 0xcc, 0x0f, 0xc1, 0x59, 0x4f, 0x50, 0x1e, 0xf8, 0x23,
	0xb1, 0xaf, 0x3b, 0x82, 0x20, 0x54, 0x11, 0x41, 0x71, 0x3e, 0xf0, 0xe7, 0x40, 0x78, 0x81, 0x3f,
	0x9a, 0x83, 0xce, 0x3b, 0x54, 0xa2, 0x61, 0x38, 0xcc, 0x32, 0x06, 0x7e, 0x31, 0xba, 0xf1, 0x5c,
	0x0e, 0xbc, 0x05, 0x42, 0xef, 0xe8, 0x2d, 0x90, 0xfd, 0x09, 0x6c, 0xb4, 0xf0, 0x73, 0xa6, 0x89,
	0x21, 0x7a, 0xaa, 0xcd, 0xcc, 0x7b, 0x47, 0x09, 0xbc, 0x77, 0xee, 0xc7, 0xff, 0xfe, 0x97, 0x8f,
	0x78, 0x7f, 0x66, 0xd8, 0x66, 0x1f, 0xfe, 0x49, 0x81, 0xb5, 0xc0, 0x44, 0x8f, 0x52, 0xb0, 0xdd,
	0xac, 0x1d, 0xd6, 0x6b, 0xf5, 0x43, 0xbd, 0xd9, 0x2a, 0xb6, 0x4e, 0x9a, 0xfa, 0x49, 0xbd, 0xd9,
	0xa8, 0x96, 0x6b, 0x07, 0xb5, 0x6a, 0x25, 0xb1, 0x84, 0xb6, 0x61, 0xf3, 0x1c, 0xfd, 0x61, 0xb1,
	0xd6, 0xaa, 0xd5, 0x0f, 0x13, 0xca, 0x1c, 0x5a, 0xf3, 0xa4, 0x5c, 0xae, 0x36, 0x9b, 0x89, 0xd0,
	0x1c, 0x5a, 0xf5, 0xf3, 0x46, 0x4d, 0xab, 0x56, 0x12, 0x2a, 0xda, 0x82, 0x3b, 0xe7, 0x68, 0x07,
	0xc5, 0xa3, 0xa3, 0x6a, 0x3d, 0x11, 0xde, 0x0e, 0x7f, 0xf1, 0xc7, 0xd4, 0xd2, 0x87, 0xbf, 0x53,
	0x60, 0x75, 0x76, 0xe8, 0x41, 0xdf, 0x81, 0xad, 0xe3, 0xea, 0x71, 0xa9, 0xaa, 0xcd, 0x17, 0x32,
	0x09, 0x1b, 0x41, 0x72, 0xb1, 0xdc, 0xaa, 0xfd, 0xbc, 0x2a, 0x44, 0x0c, 0x52, 0x6a, 0x75, 0x49,
	0x0b, 0xa1, 0x4d, 0x40, 0x41, 0xda, 0x27, 0xc5, 0xda, 0x51, 0x42, 0x95, 0x32, 0xfc, 0x43, 0x81,
	0xf8, 0xcc, 0xbf, 0x6f, 0x68, 0x07, 0x92, 0x87, 0xda, 0x83, 0x93, 0xc6, 0x5b, 0x25, 0x08, 0x50,
	0xb5, 0x07, 0x27, 0xf5, 0x8a, 0xbe, 0x9f, 0x50, 0xde, 0x42, 0x29, 0x24, 0x42, 0x6f, 0xa1, 0xdc,
	0x4b, 0xa8, 0xe8, 0x2e, 0xdc, 0x0e, 0x50, 0xa4, 0xc8, 0xe1, 0x0b, 0x2c, 0x9e, 0x4d, 0x97, 0x2f,
	0xb0, 0x48, 0x8b, 0x46, 0xa4, 0x36, 0x0c, 0xd6, 0xcf, 0xb5, 0x3d, 0x94, 0x81, 0x9d, 0xf2, 0x83,
	0xe3, 0xc6, 0x51, 0xb1, 0x56, 0x6f, 0xcd, 0x57, 0x6a, 0x07, 0x92, 0x17, 0x4e, 0x78, 0x1e, 0x56,
	0xd0, 0x07, 0x70, 0xf7, 0x02, 0xf5, 0xa0, 0x58, 0x3b, 0xaa, 0x56, 0x12, 0x21, 0x71, 0x6b, 0xe9,
	0x93, 0x3f, 0x9f, 0xa5, 0x94, 0x97, 0x67, 0x29, 0xe5, 0xeb, 0xb3, 0x94, 0xf2, 0xef, 0xb3, 0x94,
	0xf2, 0xe5, 0xeb, 0xd4, 0xd2, 0xd7, 0xaf, 0x53, 0x4b, 0xdf, 0xbc, 0x4e, 0x2d, 0x3d, 0xfa, 0xfe,
	0xb7, 0xa6, 0xc2, 0x73, 0x9e, 0x08, 0xe2, 0xc5, 0xda, 0x8e, 0xb8, 0xe4, 0x7b, 0xff, 0x0f, 0x00,
	0x00, 0xff, 0xff, 0xf9, 0xe1, 0x04, 0x97, 0xab, 0x16, 0x00, 0x00,
}

func (this *Group) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Group)
	if !ok {
		that2, ok := that.(Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if this.CreatedHeight != that1.CreatedHeight {
		return false
	}
	return true
}
func (this *Round1Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round1Info)
	if !ok {
		that2, ok := that.(Round1Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.CoefficientCommits) != len(that1.CoefficientCommits) {
		return false
	}
	for i := range this.CoefficientCommits {
		if !bytes.Equal(this.CoefficientCommits[i], that1.CoefficientCommits[i]) {
			return false
		}
	}
	if !bytes.Equal(this.OneTimePubKey, that1.OneTimePubKey) {
		return false
	}
	if !bytes.Equal(this.A0Sig, that1.A0Sig) {
		return false
	}
	if !bytes.Equal(this.OneTimeSig, that1.OneTimeSig) {
		return false
	}
	return true
}
func (this *Round2Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round2Info)
	if !ok {
		that2, ok := that.(Round2Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.EncryptedSecretShares) != len(that1.EncryptedSecretShares) {
		return false
	}
	for i := range this.EncryptedSecretShares {
		if !bytes.Equal(this.EncryptedSecretShares[i], that1.EncryptedSecretShares[i]) {
			return false
		}
	}
	return true
}
func (this *DE) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DE)
	if !ok {
		that2, ok := that.(DE)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	return true
}
func (this *DEQueue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DEQueue)
	if !ok {
		that2, ok := that.(DEQueue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	if this.Tail != that1.Tail {
		return false
	}
	return true
}
func (this *Signing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signing)
	if !ok {
		that2, ok := that.(Signing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SigningID != that1.SigningID {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if len(this.AssignedMembers) != len(that1.AssignedMembers) {
		return false
	}
	for i := range this.AssignedMembers {
		if !this.AssignedMembers[i].Equal(&that1.AssignedMembers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Message, that1.Message) {
		return false
	}
	if !bytes.Equal(this.GroupPubNonce, that1.GroupPubNonce) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if this.CreatedHeight != that1.CreatedHeight {
		return false
	}
	if this.Requester != that1.Requester {
		return false
	}
	return true
}
func (this *AssignedMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignedMember)
	if !ok {
		that2, ok := that.(AssignedMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.Member != that1.Member {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	if !bytes.Equal(this.BindingFactor, that1.BindingFactor) {
		return false
	}
	if !bytes.Equal(this.PubNonce, that1.PubNonce) {
		return false
	}
	return true
}
func (this *PendingSignings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingSignings)
	if !ok {
		that2, ok := that.(PendingSignings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SigningIds) != len(that1.SigningIds) {
		return false
	}
	for i := range this.SigningIds {
		if this.SigningIds[i] != that1.SigningIds[i] {
			return false
		}
	}
	return true
}
func (this *Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Member)
	if !ok {
		that2, ok := that.(Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.IsMalicious != that1.IsMalicious {
		return false
	}
	return true
}
func (this *Status) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Since.Equal(that1.Since) {
		return false
	}
	if !this.LastActive.Equal(that1.LastActive) {
		return false
	}
	return true
}
func (this *Confirm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Confirm)
	if !ok {
		that2, ok := that.(Confirm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.OwnPubKeySig, that1.OwnPubKeySig) {
		return false
	}
	return true
}
func (this *Complaint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Complaint)
	if !ok {
		that2, ok := that.(Complaint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Complainant != that1.Complainant {
		return false
	}
	if this.Respondent != that1.Respondent {
		return false
	}
	if !bytes.Equal(this.KeySym, that1.KeySym) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *ComplaintWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintWithStatus)
	if !ok {
		that2, ok := that.(ComplaintWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Complaint.Equal(&that1.Complaint) {
		return false
	}
	if this.ComplaintStatus != that1.ComplaintStatus {
		return false
	}
	return true
}
func (this *ComplaintsWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintsWithStatus)
	if !ok {
		that2, ok := that.(ComplaintsWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.ComplaintsWithStatus) != len(that1.ComplaintsWithStatus) {
		return false
	}
	for i := range this.ComplaintsWithStatus {
		if !this.ComplaintsWithStatus[i].Equal(&that1.ComplaintsWithStatus[i]) {
			return false
		}
	}
	return true
}
func (this *PendingProcessGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingProcessGroups)
	if !ok {
		that2, ok := that.(PendingProcessGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GroupIDs) != len(that1.GroupIDs) {
		return false
	}
	for i := range this.GroupIDs {
		if this.GroupIDs[i] != that1.GroupIDs[i] {
			return false
		}
	}
	return true
}
func (this *PendingProcessSignings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingProcessSignings)
	if !ok {
		that2, ok := that.(PendingProcessSignings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SigningIDs) != len(that1.SigningIDs) {
		return false
	}
	for i := range this.SigningIDs {
		if this.SigningIDs[i] != that1.SigningIDs[i] {
			return false
		}
	}
	return true
}
func (this *PendingReplaceGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingReplaceGroup)
	if !ok {
		that2, ok := that.(PendingReplaceGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SigningID != that1.SigningID {
		return false
	}
	if this.FromGroupID != that1.FromGroupID {
		return false
	}
	if this.ToGroupID != that1.ToGroupID {
		return false
	}
	if !this.ExecTime.Equal(that1.ExecTime) {
		return false
	}
	return true
}
func (this *PendingReplaceGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingReplaceGroups)
	if !ok {
		that2, ok := that.(PendingReplaceGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PendingReplaceGroups) != len(that1.PendingReplaceGroups) {
		return false
	}
	for i := range this.PendingReplaceGroups {
		if !this.PendingReplaceGroups[i].Equal(&that1.PendingReplaceGroups[i]) {
			return false
		}
	}
	return true
}
func (this *PartialSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartialSignature)
	if !ok {
		that2, ok := that.(PartialSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *TextRequestSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TextRequestSignature)
	if !ok {
		that2, ok := that.(TextRequestSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Message, that1.Message) {
		return false
	}
	return true
}
func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedHeight != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Threshold != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round1Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round1Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round1Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OneTimeSig) > 0 {
		i -= len(m.OneTimeSig)
		copy(dAtA[i:], m.OneTimeSig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimeSig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.A0Sig) > 0 {
		i -= len(m.A0Sig)
		copy(dAtA[i:], m.A0Sig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.A0Sig)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OneTimePubKey) > 0 {
		i -= len(m.OneTimePubKey)
		copy(dAtA[i:], m.OneTimePubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimePubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CoefficientCommits) > 0 {
		for iNdEx := len(m.CoefficientCommits) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CoefficientCommits[iNdEx])
			copy(dAtA[i:], m.CoefficientCommits[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.CoefficientCommits[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round2Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round2Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSecretShares) > 0 {
		for iNdEx := len(m.EncryptedSecretShares) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedSecretShares[iNdEx])
			copy(dAtA[i:], m.EncryptedSecretShares[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.EncryptedSecretShares[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DEQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DEQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DEQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tail != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Tail))
		i--
		dAtA[i] = 0x10
	}
	if m.Head != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Head))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Signing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x52
	}
	if m.CreatedHeight != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.CreatedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Fee) > 0 {
		for iNdEx := len(m.Fee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Fee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GroupPubNonce) > 0 {
		i -= len(m.GroupPubNonce)
		copy(dAtA[i:], m.GroupPubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.GroupPubNonce)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssignedMembers) > 0 {
		for iNdEx := len(m.AssignedMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssignedMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.SigningID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.SigningID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssignedMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignedMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubNonce) > 0 {
		i -= len(m.PubNonce)
		copy(dAtA[i:], m.PubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubNonce)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BindingFactor) > 0 {
		i -= len(m.BindingFactor)
		copy(dAtA[i:], m.BindingFactor)
		i = encodeVarintTss(dAtA, i, uint64(len(m.BindingFactor)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingSignings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingSignings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingSignings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		dAtA2 := make([]byte, len(m.SigningIds)*10)
		var j1 int
		for _, num := range m.SigningIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTss(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMalicious {
		i--
		if m.IsMalicious {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastActive, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActive):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintTss(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Since, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Since):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTss(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Confirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Confirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Confirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnPubKeySig) > 0 {
		i -= len(m.OwnPubKeySig)
		copy(dAtA[i:], m.OwnPubKeySig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OwnPubKeySig)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Complaint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Complaint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Complaint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeySym) > 0 {
		i -= len(m.KeySym)
		copy(dAtA[i:], m.KeySym)
		i = encodeVarintTss(dAtA, i, uint64(len(m.KeySym)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Respondent != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Respondent))
		i--
		dAtA[i] = 0x10
	}
	if m.Complainant != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Complainant))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplaintWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComplaintStatus != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ComplaintStatus))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Complaint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTss(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComplaintsWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintsWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintsWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ComplaintsWithStatus) > 0 {
		for iNdEx := len(m.ComplaintsWithStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ComplaintsWithStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingProcessGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingProcessGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingProcessGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupIDs) > 0 {
		dAtA7 := make([]byte, len(m.GroupIDs)*10)
		var j6 int
		for _, num := range m.GroupIDs {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintTss(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PendingProcessSignings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingProcessSignings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingProcessSignings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningIDs) > 0 {
		dAtA9 := make([]byte, len(m.SigningIDs)*10)
		var j8 int
		for _, num := range m.SigningIDs {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTss(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PendingReplaceGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingReplaceGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingReplaceGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.ExecTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintTss(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x22
	if m.ToGroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ToGroupID))
		i--
		dAtA[i] = 0x18
	}
	if m.FromGroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.FromGroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.SigningID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.SigningID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingReplaceGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingReplaceGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingReplaceGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PendingReplaceGroups) > 0 {
		for iNdEx := len(m.PendingReplaceGroups) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingReplaceGroups[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PartialSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TextRequestSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextRequestSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextRequestSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTss(dAtA []byte, offset int, v uint64) int {
	offset -= sovTss(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	if m.Size_ != 0 {
		n += 1 + sovTss(uint64(m.Size_))
	}
	if m.Threshold != 0 {
		n += 1 + sovTss(uint64(m.Threshold))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTss(uint64(m.CreatedHeight))
	}
	return n
}

func (m *Round1Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.CoefficientCommits) > 0 {
		for _, b := range m.CoefficientCommits {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.OneTimePubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.A0Sig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.OneTimeSig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Round2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.EncryptedSecretShares) > 0 {
		for _, b := range m.EncryptedSecretShares {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *DE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *DEQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != 0 {
		n += 1 + sovTss(uint64(m.Head))
	}
	if m.Tail != 0 {
		n += 1 + sovTss(uint64(m.Tail))
	}
	return n
}

func (m *Signing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningID != 0 {
		n += 1 + sovTss(uint64(m.SigningID))
	}
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	if len(m.AssignedMembers) > 0 {
		for _, e := range m.AssignedMembers {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.GroupPubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	if m.CreatedHeight != 0 {
		n += 1 + sovTss(uint64(m.CreatedHeight))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *AssignedMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.BindingFactor)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *PendingSignings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		l = 0
		for _, e := range m.SigningIds {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.IsMalicious {
		n += 2
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Since)
	n += 1 + l + sovTss(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastActive)
	n += 1 + l + sovTss(uint64(l))
	return n
}

func (m *Confirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.OwnPubKeySig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Complaint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Complainant != 0 {
		n += 1 + sovTss(uint64(m.Complainant))
	}
	if m.Respondent != 0 {
		n += 1 + sovTss(uint64(m.Respondent))
	}
	l = len(m.KeySym)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *ComplaintWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Complaint.Size()
	n += 1 + l + sovTss(uint64(l))
	if m.ComplaintStatus != 0 {
		n += 1 + sovTss(uint64(m.ComplaintStatus))
	}
	return n
}

func (m *ComplaintsWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.ComplaintsWithStatus) > 0 {
		for _, e := range m.ComplaintsWithStatus {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *PendingProcessGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GroupIDs) > 0 {
		l = 0
		for _, e := range m.GroupIDs {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *PendingProcessSignings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningIDs) > 0 {
		l = 0
		for _, e := range m.SigningIDs {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *PendingReplaceGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningID != 0 {
		n += 1 + sovTss(uint64(m.SigningID))
	}
	if m.FromGroupID != 0 {
		n += 1 + sovTss(uint64(m.FromGroupID))
	}
	if m.ToGroupID != 0 {
		n += 1 + sovTss(uint64(m.ToGroupID))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.ExecTime)
	n += 1 + l + sovTss(uint64(l))
	return n
}

func (m *PendingReplaceGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PendingReplaceGroups) > 0 {
		for _, e := range m.PendingReplaceGroups {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *PartialSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *TextRequestSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func sovTss(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTss(x uint64) (n int) {
	return sovTss(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round1Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round1Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round1Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoefficientCommits", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoefficientCommits = append(m.CoefficientCommits, make([]byte, postIndex-iNdEx))
			copy(m.CoefficientCommits[len(m.CoefficientCommits)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimePubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimePubKey = append(m.OneTimePubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimePubKey == nil {
				m.OneTimePubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A0Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A0Sig = append(m.A0Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.A0Sig == nil {
				m.A0Sig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimeSig = append(m.OneTimeSig[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimeSig == nil {
				m.OneTimeSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSecretShares = append(m.EncryptedSecretShares, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedSecretShares[len(m.EncryptedSecretShares)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DEQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DEQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DEQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningID", wireType)
			}
			m.SigningID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedMembers = append(m.AssignedMembers, AssignedMember{})
			if err := m.AssignedMembers[len(m.AssignedMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubNonce = append(m.GroupPubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubNonce == nil {
				m.GroupPubNonce = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, types.Coin{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SigningStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedHeight", wireType)
			}
			m.CreatedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindingFactor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindingFactor = append(m.BindingFactor[:0], dAtA[iNdEx:postIndex]...)
			if m.BindingFactor == nil {
				m.BindingFactor = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubNonce = append(m.PubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.PubNonce == nil {
				m.PubNonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingSignings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingSignings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingSignings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SigningIds = append(m.SigningIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SigningIds) == 0 {
					m.SigningIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SigningIds = append(m.SigningIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMalicious", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMalicious = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= MemberStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Since, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastActive, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Confirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Confirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Confirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnPubKeySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnPubKeySig = append(m.OwnPubKeySig[:0], dAtA[iNdEx:postIndex]...)
			if m.OwnPubKeySig == nil {
				m.OwnPubKeySig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Complaint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Complaint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Complaint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complainant", wireType)
			}
			m.Complainant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Complainant |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Respondent", wireType)
			}
			m.Respondent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Respondent |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySym", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySym = append(m.KeySym[:0], dAtA[iNdEx:postIndex]...)
			if m.KeySym == nil {
				m.KeySym = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complaint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Complaint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintStatus", wireType)
			}
			m.ComplaintStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplaintStatus |= ComplaintStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintsWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintsWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintsWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintsWithStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComplaintsWithStatus = append(m.ComplaintsWithStatus, ComplaintWithStatus{})
			if err := m.ComplaintsWithStatus[len(m.ComplaintsWithStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingProcessGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingProcessGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingProcessGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_bandprotocol_chain_v2_pkg_tss.GroupID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupIDs = append(m.GroupIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupIDs) == 0 {
					m.GroupIDs = make([]github_com_bandprotocol_chain_v2_pkg_tss.GroupID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_bandprotocol_chain_v2_pkg_tss.GroupID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupIDs = append(m.GroupIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingProcessSignings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingProcessSignings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingProcessSignings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v github_com_bandprotocol_chain_v2_pkg_tss.SigningID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SigningIDs = append(m.SigningIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SigningIDs) == 0 {
					m.SigningIDs = make([]github_com_bandprotocol_chain_v2_pkg_tss.SigningID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_com_bandprotocol_chain_v2_pkg_tss.SigningID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SigningIDs = append(m.SigningIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingReplaceGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingReplaceGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingReplaceGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningID", wireType)
			}
			m.SigningID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGroupID", wireType)
			}
			m.FromGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToGroupID", wireType)
			}
			m.ToGroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToGroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.ExecTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingReplaceGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingReplaceGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingReplaceGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingReplaceGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingReplaceGroups = append(m.PendingReplaceGroups, PendingReplaceGroup{})
			if err := m.PendingReplaceGroups[len(m.PendingReplaceGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextRequestSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextRequestSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextRequestSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTss(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTss
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTss
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTss
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTss
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTss        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTss          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTss = fmt.Errorf("proto: unexpected end of group")
)
