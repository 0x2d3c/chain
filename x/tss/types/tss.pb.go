// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tss/v1beta1/tss.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_bandprotocol_chain_v2_pkg_tss "github.com/bandprotocol/chain/v2/pkg/tss"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GroupStatus is an enumeration of the possible statuses of a group.
type GroupStatus int32

const (
	// GROUP_STATUS_UNSPECIFIED is the status of a group that has not been specified.
	GROUP_STATUS_UNSPECIFIED GroupStatus = 0
	// GROUP_STATUS_ROUND_1 is the status of a group that is in the first round of the protocol.
	GROUP_STATUS_ROUND_1 GroupStatus = 1
	// GROUP_STATUS_ROUND_2 is the status of a group that is in the second round of the protocol.
	GROUP_STATUS_ROUND_2 GroupStatus = 2
	// GROUP_STATUS_ROUND_3 is the status of a group that is in the third round of the protocol.
	GROUP_STATUS_ROUND_3 GroupStatus = 3
	// GROUP_STATUS_ACTIVE is the status of a group that is actively participating in the protocol.
	GROUP_STATUS_ACTIVE GroupStatus = 4
	// GROUP_STATUS_FALLEN is the status of a group that has fallen out of the protocol.
	GROUP_STATUS_FALLEN GroupStatus = 5
)

var GroupStatus_name = map[int32]string{
	0: "GROUP_STATUS_UNSPECIFIED",
	1: "GROUP_STATUS_ROUND_1",
	2: "GROUP_STATUS_ROUND_2",
	3: "GROUP_STATUS_ROUND_3",
	4: "GROUP_STATUS_ACTIVE",
	5: "GROUP_STATUS_FALLEN",
}

var GroupStatus_value = map[string]int32{
	"GROUP_STATUS_UNSPECIFIED": 0,
	"GROUP_STATUS_ROUND_1":     1,
	"GROUP_STATUS_ROUND_2":     2,
	"GROUP_STATUS_ROUND_3":     3,
	"GROUP_STATUS_ACTIVE":      4,
	"GROUP_STATUS_FALLEN":      5,
}

func (x GroupStatus) String() string {
	return proto.EnumName(GroupStatus_name, int32(x))
}

func (GroupStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}

// ComplaintStatus represents the status of a complaint.
type ComplaintStatus int32

const (
	// COMPLAINT_STATUS_UNSPECIFIED represents an undefined status of the complaint.
	COMPLAINT_STATUS_UNSPECIFIED ComplaintStatus = 0
	// COMPLAINT_STATUS_SUCCESS represents a successful complaint.
	COMPLAINT_STATUS_SUCCESS ComplaintStatus = 1
	// COMPLAINT_STATUS_FAILED represents a failed complaint.
	COMPLAINT_STATUS_FAILED ComplaintStatus = 2
)

var ComplaintStatus_name = map[int32]string{
	0: "COMPLAINT_STATUS_UNSPECIFIED",
	1: "COMPLAINT_STATUS_SUCCESS",
	2: "COMPLAINT_STATUS_FAILED",
}

var ComplaintStatus_value = map[string]int32{
	"COMPLAINT_STATUS_UNSPECIFIED": 0,
	"COMPLAINT_STATUS_SUCCESS":     1,
	"COMPLAINT_STATUS_FAILED":      2,
}

func (x ComplaintStatus) String() string {
	return proto.EnumName(ComplaintStatus_name, int32(x))
}

func (ComplaintStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}

// Group is a type representing a participant group in a Distributed Key Generation or signing process.
type Group struct {
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// size is the number of members in the group.
	Size_ uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// threshold is the minimum number of members needed to generate a valid signature.
	Threshold uint64 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// pub_key is the public key generated by the group after successful completion of the DKG process.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// status represents the current stage of the group in the DKG or signing process.
	Status GroupStatus `protobuf:"varint,5,opt,name=status,proto3,enum=tss.v1beta1.GroupStatus" json:"status,omitempty"`
	// create_time is the time when the group was created.
	CreateTime time.Time `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time"`
	// expiry_time is the time when the group will be dissolved if it has not finished its process.
	ExpiryTime *time.Time `protobuf:"bytes,7,opt,name=expiry_time,json=expiryTime,proto3,stdtime" json:"expiry_time,omitempty"`
}

func (m *Group) Reset()         { *m = Group{} }
func (m *Group) String() string { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()    {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{0}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Group) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Group) GetThreshold() uint64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *Group) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Group) GetStatus() GroupStatus {
	if m != nil {
		return m.Status
	}
	return GROUP_STATUS_UNSPECIFIED
}

func (m *Group) GetCreateTime() time.Time {
	if m != nil {
		return m.CreateTime
	}
	return time.Time{}
}

func (m *Group) GetExpiryTime() *time.Time {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

// Round1Info contains all necessary information for handling round 1 of the DKG process.
type Round1Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// coefficients_commit is a list of commitments to the coefficients of the member's secret polynomial.
	CoefficientsCommit github_com_bandprotocol_chain_v2_pkg_tss.Points `protobuf:"bytes,2,rep,name=coefficients_commit,json=coefficientsCommit,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Points" json:"coefficients_commit,omitempty"`
	// one_time_pub_key is the one-time public key used by the member to encrypt secret shares.
	OneTimePubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=one_time_pub_key,json=oneTimePubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"one_time_pub_key,omitempty"`
	// a0_sig is the member's signature on the first coefficient of its secret polynomial.
	A0Sig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,4,opt,name=a0_sig,json=a0Sig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"a0_sig,omitempty"`
	// one_time_sig is the member's signature on its one-time public key.
	OneTimeSig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,5,opt,name=one_time_sig,json=oneTimeSig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"one_time_sig,omitempty"`
}

func (m *Round1Info) Reset()         { *m = Round1Info{} }
func (m *Round1Info) String() string { return proto.CompactTextString(m) }
func (*Round1Info) ProtoMessage()    {}
func (*Round1Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{1}
}
func (m *Round1Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round1Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round1Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round1Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round1Info.Merge(m, src)
}
func (m *Round1Info) XXX_Size() int {
	return m.Size()
}
func (m *Round1Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round1Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round1Info proto.InternalMessageInfo

func (m *Round1Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round1Info) GetCoefficientsCommit() github_com_bandprotocol_chain_v2_pkg_tss.Points {
	if m != nil {
		return m.CoefficientsCommit
	}
	return nil
}

func (m *Round1Info) GetOneTimePubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.OneTimePubKey
	}
	return nil
}

func (m *Round1Info) GetA0Sig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.A0Sig
	}
	return nil
}

func (m *Round1Info) GetOneTimeSig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OneTimeSig
	}
	return nil
}

// Round2Info contains all necessary information for handling round 2 of the DKG process.
type Round2Info struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// encrypted_secret_shares is a list of secret shares encrypted under the public keys of other members.
	EncryptedSecretShares github_com_bandprotocol_chain_v2_pkg_tss.Scalars `protobuf:"bytes,2,rep,name=encrypted_secret_shares,json=encryptedSecretShares,proto3,castrepeated=github.com/bandprotocol/chain/v2/pkg/tss.Scalars" json:"encrypted_secret_shares,omitempty"`
}

func (m *Round2Info) Reset()         { *m = Round2Info{} }
func (m *Round2Info) String() string { return proto.CompactTextString(m) }
func (*Round2Info) ProtoMessage()    {}
func (*Round2Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{2}
}
func (m *Round2Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Round2Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Round2Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Round2Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Round2Info.Merge(m, src)
}
func (m *Round2Info) XXX_Size() int {
	return m.Size()
}
func (m *Round2Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Round2Info.DiscardUnknown(m)
}

var xxx_messageInfo_Round2Info proto.InternalMessageInfo

func (m *Round2Info) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Round2Info) GetEncryptedSecretShares() github_com_bandprotocol_chain_v2_pkg_tss.Scalars {
	if m != nil {
		return m.EncryptedSecretShares
	}
	return nil
}

// DE contains the public parts of a member's decryption and encryption keys.
type DE struct {
	// pub_d is the public value of own commitment (D).
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,1,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public value of own commitment (E).
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,2,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
}

func (m *DE) Reset()         { *m = DE{} }
func (m *DE) String() string { return proto.CompactTextString(m) }
func (*DE) ProtoMessage()    {}
func (*DE) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{3}
}
func (m *DE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DE.Merge(m, src)
}
func (m *DE) XXX_Size() int {
	return m.Size()
}
func (m *DE) XXX_DiscardUnknown() {
	xxx_messageInfo_DE.DiscardUnknown(m)
}

var xxx_messageInfo_DE proto.InternalMessageInfo

func (m *DE) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *DE) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

// DEQueue is a simple queue data structure for holding DE objects.
type DEQueue struct {
	// head is the index of the first element in the queue.
	Head uint64 `protobuf:"varint,1,opt,name=head,proto3" json:"head,omitempty"`
	// tail is the index of the last element in the queue.
	Tail uint64 `protobuf:"varint,2,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (m *DEQueue) Reset()         { *m = DEQueue{} }
func (m *DEQueue) String() string { return proto.CompactTextString(m) }
func (*DEQueue) ProtoMessage()    {}
func (*DEQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{4}
}
func (m *DEQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DEQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DEQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DEQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DEQueue.Merge(m, src)
}
func (m *DEQueue) XXX_Size() int {
	return m.Size()
}
func (m *DEQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_DEQueue.DiscardUnknown(m)
}

var xxx_messageInfo_DEQueue proto.InternalMessageInfo

func (m *DEQueue) GetHead() uint64 {
	if m != nil {
		return m.Head
	}
	return 0
}

func (m *DEQueue) GetTail() uint64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

// Signing contains all necessary information for handling a signing request.
type Signing struct {
	// signing_id is the unique identifier of the signing process.
	SigningID github_com_bandprotocol_chain_v2_pkg_tss.SigningID `protobuf:"varint,1,opt,name=signing_id,json=signingId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.SigningID" json:"signing_id,omitempty"`
	// group_id is the unique identifier of the group.
	GroupID github_com_bandprotocol_chain_v2_pkg_tss.GroupID `protobuf:"varint,2,opt,name=group_id,json=groupId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.GroupID" json:"group_id,omitempty"`
	// assigned_members is a list of members assigned to the signing process.
	AssignedMembers []AssignedMember `protobuf:"bytes,3,rep,name=assigned_members,json=assignedMembers,proto3" json:"assigned_members"`
	// message is the message to be signed.
	Message []byte `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// group_pub_nonce is the public nonce generated by the group for this signing process.
	GroupPubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,5,opt,name=group_pub_nonce,json=groupPubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"group_pub_nonce,omitempty"`
	// commitment is the commitment to the group's signature on the message.
	Commitment []byte `protobuf:"bytes,6,opt,name=commitment,proto3" json:"commitment,omitempty"`
	// signature is the group's signature on the message.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,7,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
	// request_time is the time when the signing request was made.
	RequestTime time.Time `protobuf:"bytes,8,opt,name=request_time,json=requestTime,proto3,stdtime" json:"request_time"`
	// expiry_time is the time when the signing request will expire if not completed.
	ExpiryTime *time.Time `protobuf:"bytes,9,opt,name=expiry_time,json=expiryTime,proto3,stdtime" json:"expiry_time,omitempty"`
}

func (m *Signing) Reset()         { *m = Signing{} }
func (m *Signing) String() string { return proto.CompactTextString(m) }
func (*Signing) ProtoMessage()    {}
func (*Signing) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{5}
}
func (m *Signing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signing.Merge(m, src)
}
func (m *Signing) XXX_Size() int {
	return m.Size()
}
func (m *Signing) XXX_DiscardUnknown() {
	xxx_messageInfo_Signing.DiscardUnknown(m)
}

var xxx_messageInfo_Signing proto.InternalMessageInfo

func (m *Signing) GetSigningID() github_com_bandprotocol_chain_v2_pkg_tss.SigningID {
	if m != nil {
		return m.SigningID
	}
	return 0
}

func (m *Signing) GetGroupID() github_com_bandprotocol_chain_v2_pkg_tss.GroupID {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *Signing) GetAssignedMembers() []AssignedMember {
	if m != nil {
		return m.AssignedMembers
	}
	return nil
}

func (m *Signing) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Signing) GetGroupPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.GroupPubNonce
	}
	return nil
}

func (m *Signing) GetCommitment() []byte {
	if m != nil {
		return m.Commitment
	}
	return nil
}

func (m *Signing) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signing) GetRequestTime() time.Time {
	if m != nil {
		return m.RequestTime
	}
	return time.Time{}
}

func (m *Signing) GetExpiryTime() *time.Time {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

// AssignedMember is a type representing a member that has been assigned to a signing process.
type AssignedMember struct {
	// member_id is the unique identifier of the member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// member is the human-readable name of the member.
	Member string `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
	// pub_d is the public part of a member's decryption key.
	PubD github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=pub_d,json=pubD,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_d,omitempty"`
	// pub_e is the public part of a member's encryption key.
	PubE github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,4,opt,name=pub_e,json=pubE,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_e,omitempty"`
	// pub_nonce is the public nonce of the member for the signing process.
	PubNonce github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,5,opt,name=pub_nonce,json=pubNonce,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_nonce,omitempty"`
}

func (m *AssignedMember) Reset()         { *m = AssignedMember{} }
func (m *AssignedMember) String() string { return proto.CompactTextString(m) }
func (*AssignedMember) ProtoMessage()    {}
func (*AssignedMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{6}
}
func (m *AssignedMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignedMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignedMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignedMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignedMember.Merge(m, src)
}
func (m *AssignedMember) XXX_Size() int {
	return m.Size()
}
func (m *AssignedMember) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignedMember.DiscardUnknown(m)
}

var xxx_messageInfo_AssignedMember proto.InternalMessageInfo

func (m *AssignedMember) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *AssignedMember) GetMember() string {
	if m != nil {
		return m.Member
	}
	return ""
}

func (m *AssignedMember) GetPubD() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubD
	}
	return nil
}

func (m *AssignedMember) GetPubE() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubE
	}
	return nil
}

func (m *AssignedMember) GetPubNonce() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubNonce
	}
	return nil
}

// PendingSignings is a list of all signing processes that are currently pending.
type PendingSignings struct {
	// signing_ids is a list of identifiers for the signing processes.
	SigningIds []uint64 `protobuf:"varint,1,rep,packed,name=signing_ids,json=signingIds,proto3" json:"signing_ids,omitempty"`
}

func (m *PendingSignings) Reset()         { *m = PendingSignings{} }
func (m *PendingSignings) String() string { return proto.CompactTextString(m) }
func (*PendingSignings) ProtoMessage()    {}
func (*PendingSignings) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{7}
}
func (m *PendingSignings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingSignings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingSignings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingSignings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingSignings.Merge(m, src)
}
func (m *PendingSignings) XXX_Size() int {
	return m.Size()
}
func (m *PendingSignings) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingSignings.DiscardUnknown(m)
}

var xxx_messageInfo_PendingSignings proto.InternalMessageInfo

func (m *PendingSignings) GetSigningIds() []uint64 {
	if m != nil {
		return m.SigningIds
	}
	return nil
}

// Member is a type representing a member of the group.
type Member struct {
	// id is the unique identifier of a member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=id,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"id,omitempty"`
	// address is the address of the member.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// pub_key is the public key of the member.
	PubKey github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"pub_key,omitempty"`
	// is_malicious is a boolean flag indicating whether the member is considered malicious.
	IsMalicious bool `protobuf:"varint,4,opt,name=is_malicious,json=isMalicious,proto3" json:"is_malicious,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{8}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetPubKey() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Member) GetIsMalicious() bool {
	if m != nil {
		return m.IsMalicious
	}
	return false
}

// Confirm is a message type used to confirm participation in the protocol.
type Confirm struct {
	// member_id is the unique identifier of a group member.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// own_pub_key_sig is a signature over the member's own public key.
	OwnPubKeySig github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=own_pub_key_sig,json=ownPubKeySig,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"own_pub_key_sig,omitempty"`
}

func (m *Confirm) Reset()         { *m = Confirm{} }
func (m *Confirm) String() string { return proto.CompactTextString(m) }
func (*Confirm) ProtoMessage()    {}
func (*Confirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{9}
}
func (m *Confirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Confirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Confirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Confirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Confirm.Merge(m, src)
}
func (m *Confirm) XXX_Size() int {
	return m.Size()
}
func (m *Confirm) XXX_DiscardUnknown() {
	xxx_messageInfo_Confirm.DiscardUnknown(m)
}

var xxx_messageInfo_Confirm proto.InternalMessageInfo

func (m *Confirm) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *Confirm) GetOwnPubKeySig() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.OwnPubKeySig
	}
	return nil
}

// Complaint is a message type used to issue a complaint against a member.
type Complaint struct {
	// complainer is the member issuing the complaint.
	Complainer github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=complainer,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"complainer,omitempty"`
	// complainant is the member against whom the complaint is issued.
	Complainant github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,2,opt,name=complainant,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"complainant,omitempty"`
	// key_sym is a symmetric key between complainer's private key and complainant's public key.
	KeySym github_com_bandprotocol_chain_v2_pkg_tss.Point `protobuf:"bytes,3,opt,name=key_sym,json=keySym,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Point" json:"key_sym,omitempty"`
	// signature is the complaint signature that can do a symmetric key validation and complaint verification.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature `protobuf:"bytes,4,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.ComplaintSignature" json:"signature,omitempty"`
}

func (m *Complaint) Reset()         { *m = Complaint{} }
func (m *Complaint) String() string { return proto.CompactTextString(m) }
func (*Complaint) ProtoMessage()    {}
func (*Complaint) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{10}
}
func (m *Complaint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Complaint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Complaint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Complaint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Complaint.Merge(m, src)
}
func (m *Complaint) XXX_Size() int {
	return m.Size()
}
func (m *Complaint) XXX_DiscardUnknown() {
	xxx_messageInfo_Complaint.DiscardUnknown(m)
}

var xxx_messageInfo_Complaint proto.InternalMessageInfo

func (m *Complaint) GetComplainer() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Complainer
	}
	return 0
}

func (m *Complaint) GetComplainant() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.Complainant
	}
	return 0
}

func (m *Complaint) GetKeySym() github_com_bandprotocol_chain_v2_pkg_tss.Point {
	if m != nil {
		return m.KeySym
	}
	return nil
}

func (m *Complaint) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.ComplaintSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// ComplaintWithStatus contains information about a complaint with its status.
type ComplaintWithStatus struct {
	// complaint is the information about the complaint.
	Complaint Complaint `protobuf:"bytes,1,opt,name=complaint,proto3" json:"complaint"`
	// complaint_status is the status of the complaint.
	ComplaintStatus ComplaintStatus `protobuf:"varint,2,opt,name=complaint_status,json=complaintStatus,proto3,enum=tss.v1beta1.ComplaintStatus" json:"complaint_status,omitempty"`
}

func (m *ComplaintWithStatus) Reset()         { *m = ComplaintWithStatus{} }
func (m *ComplaintWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintWithStatus) ProtoMessage()    {}
func (*ComplaintWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{11}
}
func (m *ComplaintWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintWithStatus.Merge(m, src)
}
func (m *ComplaintWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintWithStatus proto.InternalMessageInfo

func (m *ComplaintWithStatus) GetComplaint() Complaint {
	if m != nil {
		return m.Complaint
	}
	return Complaint{}
}

func (m *ComplaintWithStatus) GetComplaintStatus() ComplaintStatus {
	if m != nil {
		return m.ComplaintStatus
	}
	return COMPLAINT_STATUS_UNSPECIFIED
}

// ComplaintsWithStatus contains information about multiple complaints and their status
// from a single member.
type ComplaintsWithStatus struct {
	// member_id is the identifier of the member filing the complaints.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// complaints_with_status is the list of complaints with their status from this member.
	ComplaintsWithStatus []ComplaintWithStatus `protobuf:"bytes,2,rep,name=complaints_with_status,json=complaintsWithStatus,proto3" json:"complaints_with_status"`
}

func (m *ComplaintsWithStatus) Reset()         { *m = ComplaintsWithStatus{} }
func (m *ComplaintsWithStatus) String() string { return proto.CompactTextString(m) }
func (*ComplaintsWithStatus) ProtoMessage()    {}
func (*ComplaintsWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{12}
}
func (m *ComplaintsWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplaintsWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplaintsWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplaintsWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplaintsWithStatus.Merge(m, src)
}
func (m *ComplaintsWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *ComplaintsWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplaintsWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ComplaintsWithStatus proto.InternalMessageInfo

func (m *ComplaintsWithStatus) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *ComplaintsWithStatus) GetComplaintsWithStatus() []ComplaintWithStatus {
	if m != nil {
		return m.ComplaintsWithStatus
	}
	return nil
}

// PartialSignature contains information about a member's partial signature.
type PartialSignature struct {
	// member_id is the identifier of the member providing the partial signature.
	MemberID github_com_bandprotocol_chain_v2_pkg_tss.MemberID `protobuf:"varint,1,opt,name=member_id,json=memberId,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.MemberID" json:"member_id,omitempty"`
	// signature is the partial signature provided by this member.
	Signature github_com_bandprotocol_chain_v2_pkg_tss.Signature `protobuf:"bytes,2,opt,name=signature,proto3,casttype=github.com/bandprotocol/chain/v2/pkg/tss.Signature" json:"signature,omitempty"`
}

func (m *PartialSignature) Reset()         { *m = PartialSignature{} }
func (m *PartialSignature) String() string { return proto.CompactTextString(m) }
func (*PartialSignature) ProtoMessage()    {}
func (*PartialSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_321be6f53cb0491e, []int{13}
}
func (m *PartialSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartialSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartialSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialSignature.Merge(m, src)
}
func (m *PartialSignature) XXX_Size() int {
	return m.Size()
}
func (m *PartialSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialSignature.DiscardUnknown(m)
}

var xxx_messageInfo_PartialSignature proto.InternalMessageInfo

func (m *PartialSignature) GetMemberID() github_com_bandprotocol_chain_v2_pkg_tss.MemberID {
	if m != nil {
		return m.MemberID
	}
	return 0
}

func (m *PartialSignature) GetSignature() github_com_bandprotocol_chain_v2_pkg_tss.Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterEnum("tss.v1beta1.GroupStatus", GroupStatus_name, GroupStatus_value)
	proto.RegisterEnum("tss.v1beta1.ComplaintStatus", ComplaintStatus_name, ComplaintStatus_value)
	proto.RegisterType((*Group)(nil), "tss.v1beta1.Group")
	proto.RegisterType((*Round1Info)(nil), "tss.v1beta1.Round1Info")
	proto.RegisterType((*Round2Info)(nil), "tss.v1beta1.Round2Info")
	proto.RegisterType((*DE)(nil), "tss.v1beta1.DE")
	proto.RegisterType((*DEQueue)(nil), "tss.v1beta1.DEQueue")
	proto.RegisterType((*Signing)(nil), "tss.v1beta1.Signing")
	proto.RegisterType((*AssignedMember)(nil), "tss.v1beta1.AssignedMember")
	proto.RegisterType((*PendingSignings)(nil), "tss.v1beta1.PendingSignings")
	proto.RegisterType((*Member)(nil), "tss.v1beta1.Member")
	proto.RegisterType((*Confirm)(nil), "tss.v1beta1.Confirm")
	proto.RegisterType((*Complaint)(nil), "tss.v1beta1.Complaint")
	proto.RegisterType((*ComplaintWithStatus)(nil), "tss.v1beta1.ComplaintWithStatus")
	proto.RegisterType((*ComplaintsWithStatus)(nil), "tss.v1beta1.ComplaintsWithStatus")
	proto.RegisterType((*PartialSignature)(nil), "tss.v1beta1.PartialSignature")
}

func init() { proto.RegisterFile("tss/v1beta1/tss.proto", fileDescriptor_321be6f53cb0491e) }

var fileDescriptor_321be6f53cb0491e = []byte{
	// 1304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4b, 0x6f, 0xdb, 0xc6,
	0x13, 0x37, 0xa9, 0xf7, 0x48, 0xff, 0x58, 0xd8, 0x38, 0x09, 0xe1, 0x18, 0x92, 0xfe, 0x3a, 0x09,
	0x41, 0x21, 0xd9, 0x4a, 0xdb, 0x43, 0x7b, 0x08, 0x64, 0x49, 0x31, 0xd4, 0xf8, 0xa1, 0x90, 0x76,
	0x53, 0xa4, 0x4d, 0x09, 0x8a, 0x5c, 0x53, 0x8b, 0x88, 0xa4, 0xca, 0x5d, 0x26, 0x51, 0x3f, 0x41,
	0x6f, 0xcd, 0xa9, 0x87, 0x1e, 0x7a, 0xe9, 0xa5, 0xc8, 0xad, 0xdf, 0x22, 0xc7, 0x1c, 0x7a, 0x08,
	0x7a, 0x50, 0x0a, 0x05, 0x45, 0x0f, 0xfd, 0x06, 0x3e, 0x15, 0x5c, 0x52, 0xaf, 0xda, 0x41, 0x6c,
	0xd9, 0xee, 0x6d, 0x77, 0x66, 0xf6, 0xc7, 0xd9, 0xf9, 0xcd, 0x63, 0x09, 0xd7, 0x18, 0xa5, 0x95,
	0x27, 0x1b, 0x1d, 0xcc, 0xb4, 0x8d, 0x0a, 0xa3, 0xb4, 0xdc, 0x77, 0x1d, 0xe6, 0xa0, 0xb4, 0xbf,
	0x0c, 0xc5, 0xab, 0x2b, 0xa6, 0x63, 0x3a, 0x5c, 0x5e, 0xf1, 0x57, 0x81, 0xc9, 0x6a, 0xde, 0x74,
	0x1c, 0xb3, 0x87, 0x2b, 0x7c, 0xd7, 0xf1, 0x0e, 0x2b, 0x8c, 0x58, 0x98, 0x32, 0xcd, 0xea, 0x07,
	0x06, 0xc5, 0x9f, 0x22, 0x10, 0xdb, 0x72, 0x1d, 0xaf, 0x8f, 0x1e, 0x42, 0xd2, 0xf4, 0x17, 0x2a,
	0x31, 0x24, 0xa1, 0x20, 0x94, 0xa2, 0x9b, 0x77, 0x46, 0xc3, 0x7c, 0x82, 0x2b, 0x5b, 0x8d, 0xa3,
	0x61, 0x7e, 0xdd, 0x24, 0xac, 0xeb, 0x75, 0xca, 0xba, 0x63, 0x55, 0x3a, 0x9a, 0x6d, 0x70, 0x00,
	0xdd, 0xe9, 0x55, 0xf4, 0xae, 0x46, 0xec, 0xca, 0x93, 0x6a, 0xa5, 0xff, 0xd8, 0xe4, 0xee, 0x85,
	0x67, 0xe4, 0x04, 0x07, 0x6c, 0x19, 0x08, 0x41, 0x94, 0x92, 0x6f, 0xb1, 0x24, 0xfa, 0xb8, 0x32,
	0x5f, 0xa3, 0x35, 0x48, 0xb1, 0xae, 0x8b, 0x69, 0xd7, 0xe9, 0x19, 0x52, 0x84, 0x2b, 0xa6, 0x02,
	0x74, 0x0f, 0x12, 0x7d, 0xaf, 0xa3, 0x3e, 0xc6, 0x03, 0x29, 0x5a, 0x10, 0x4a, 0x99, 0xcd, 0xea,
	0xd1, 0x30, 0x5f, 0x3e, 0xb5, 0x07, 0x6d, 0x87, 0xd8, 0x4c, 0x8e, 0xf7, 0xbd, 0xce, 0x3d, 0x3c,
	0x40, 0xeb, 0x10, 0xa7, 0x4c, 0x63, 0x1e, 0x95, 0x62, 0x05, 0xa1, 0x74, 0xa5, 0x2a, 0x95, 0x67,
	0x22, 0x17, 0x78, 0xab, 0x70, 0xbd, 0x1c, 0xda, 0xa1, 0x26, 0xa4, 0x75, 0x17, 0x6b, 0x0c, 0xab,
	0x7e, 0xc0, 0xa4, 0x78, 0x41, 0x28, 0xa5, 0xab, 0xab, 0xe5, 0x20, 0x9a, 0xe5, 0x71, 0x34, 0xcb,
	0xfb, 0xe3, 0x68, 0x6e, 0x26, 0x5f, 0x0e, 0xf3, 0x4b, 0xcf, 0xdf, 0xe4, 0x05, 0x19, 0x82, 0x83,
	0xbe, 0x0a, 0xd5, 0x20, 0x8d, 0x9f, 0xf5, 0x89, 0x3b, 0x08, 0x60, 0x12, 0xef, 0x85, 0x89, 0x06,
	0x10, 0xc1, 0x21, 0x5f, 0x5c, 0x7c, 0x1d, 0x01, 0x90, 0x1d, 0xcf, 0x36, 0x36, 0x5a, 0xf6, 0xa1,
	0x83, 0xbe, 0x86, 0x94, 0x85, 0xad, 0x0e, 0x76, 0xa7, 0x34, 0xd5, 0x46, 0xc3, 0x7c, 0x72, 0x87,
	0x0b, 0x39, 0x4f, 0x1b, 0xa7, 0x8e, 0xd2, 0xf8, 0x90, 0x9c, 0x0c, 0x30, 0x5b, 0x06, 0x32, 0xe0,
	0xaa, 0xee, 0xe0, 0xc3, 0x43, 0xa2, 0x13, 0x6c, 0x33, 0xaa, 0xea, 0x8e, 0x65, 0x11, 0x26, 0x89,
	0x85, 0x48, 0x29, 0xb3, 0x79, 0xfb, 0xc5, 0x9b, 0x7c, 0xe5, 0x6c, 0x1c, 0x50, 0x19, 0xcd, 0xe2,
	0xd5, 0x39, 0x1c, 0xfa, 0x12, 0xb2, 0x8e, 0x1d, 0xc4, 0x56, 0x1d, 0xd3, 0x1c, 0x59, 0x98, 0xe6,
	0xff, 0x39, 0x36, 0x0f, 0x77, 0x3b, 0x60, 0x7b, 0x07, 0xe2, 0xda, 0xba, 0x4a, 0x89, 0x19, 0x66,
	0xce, 0xc7, 0x47, 0xc3, 0x7c, 0xf5, 0xd4, 0x90, 0x0a, 0x31, 0x6d, 0x8d, 0x79, 0x2e, 0x96, 0x63,
	0xda, 0xba, 0x42, 0x4c, 0xf4, 0x05, 0x64, 0x26, 0xbe, 0xfa, 0xa0, 0xb1, 0x73, 0x81, 0x42, 0xe8,
	0xab, 0x42, 0xcc, 0xe2, 0xef, 0x42, 0x48, 0x6d, 0xf5, 0x3f, 0xa1, 0xb6, 0x07, 0x37, 0xb0, 0xad,
	0xbb, 0x83, 0x3e, 0xc3, 0x86, 0x4a, 0xb1, 0xee, 0x62, 0xa6, 0xd2, 0xae, 0xe6, 0x62, 0x1a, 0xd2,
	0xfb, 0xe1, 0x8b, 0x37, 0x67, 0x28, 0x72, 0x45, 0xd7, 0x7a, 0x9a, 0x4b, 0xe5, 0x6b, 0x13, 0x50,
	0x85, 0x63, 0x2a, 0x1c, 0xb2, 0xf8, 0x83, 0x00, 0x62, 0xa3, 0x89, 0xb6, 0x20, 0xe6, 0x13, 0x1c,
	0x5c, 0x68, 0x31, 0x7a, 0xa3, 0x7d, 0xaf, 0xd3, 0x18, 0x03, 0x05, 0x3d, 0x64, 0x71, 0xa0, 0x66,
	0x71, 0x03, 0x12, 0x8d, 0xe6, 0x7d, 0x0f, 0x7b, 0xd8, 0x6f, 0x4b, 0x5d, 0xac, 0x85, 0xc1, 0x96,
	0xf9, 0xda, 0x97, 0x31, 0x8d, 0xf4, 0xc6, 0xad, 0xca, 0x5f, 0x17, 0xbf, 0x8f, 0x41, 0xc2, 0xa7,
	0x90, 0xd8, 0x26, 0xea, 0x00, 0xd0, 0x60, 0x39, 0xa5, 0xa9, 0x3e, 0x1a, 0xe6, 0x53, 0xa1, 0x01,
	0xe7, 0xe9, 0x6c, 0x99, 0xc1, 0x4f, 0xc9, 0xa9, 0x10, 0xb6, 0x65, 0xcc, 0xb5, 0x62, 0xf1, 0x82,
	0x5b, 0xf1, 0x36, 0x64, 0x35, 0xea, 0x7f, 0x0a, 0x1b, 0x6a, 0x90, 0x1a, 0x54, 0x8a, 0x14, 0x22,
	0xa5, 0x74, 0xf5, 0xe6, 0x5c, 0x57, 0xac, 0x85, 0x46, 0x41, 0x22, 0x6d, 0x46, 0xfd, 0xfe, 0x26,
	0x2f, 0x6b, 0x73, 0x52, 0x8a, 0x24, 0x48, 0x58, 0x98, 0x52, 0xcd, 0xc4, 0x41, 0xb1, 0xc9, 0xe3,
	0x2d, 0x7a, 0x08, 0xcb, 0xc1, 0x1d, 0x7c, 0xd6, 0x6c, 0xc7, 0xd6, 0x71, 0x58, 0x39, 0x0b, 0x55,
	0x38, 0x87, 0x6a, 0x7b, 0x9d, 0x5d, 0x1f, 0x08, 0xe5, 0x00, 0x82, 0xbe, 0x64, 0x61, 0x9b, 0xf1,
	0xe6, 0x9c, 0x91, 0x67, 0x24, 0x68, 0x1f, 0x78, 0x30, 0x79, 0xc5, 0xf1, 0xa6, 0xbb, 0x78, 0xbd,
	0x4e, 0x81, 0xd0, 0x16, 0x64, 0x5c, 0xfc, 0x8d, 0x87, 0x29, 0x0b, 0xba, 0x79, 0xf2, 0x0c, 0x43,
	0x21, 0x1d, 0x9e, 0x3c, 0x69, 0x2a, 0xa4, 0x16, 0x98, 0x0a, 0x7f, 0x8b, 0x70, 0x65, 0x9e, 0xa1,
	0x4b, 0x6f, 0x1f, 0xd7, 0x21, 0x1e, 0xac, 0x79, 0x4a, 0xa6, 0xe4, 0x70, 0x37, 0xad, 0xf0, 0xc8,
	0x45, 0x55, 0x78, 0xf4, 0x7c, 0x15, 0x8e, 0xf6, 0x20, 0x75, 0x11, 0x49, 0x97, 0xec, 0x87, 0xf9,
	0x56, 0xac, 0xc2, 0x72, 0x1b, 0xdb, 0x06, 0xb1, 0xcd, 0xb0, 0x5c, 0x29, 0xca, 0x43, 0x7a, 0xda,
	0x06, 0xa8, 0x24, 0x14, 0x22, 0xa5, 0xa8, 0x0c, 0x93, 0x12, 0xa6, 0xc5, 0x3f, 0x05, 0x88, 0x87,
	0xcc, 0xdc, 0x07, 0xf1, 0x22, 0x29, 0x11, 0x89, 0xe1, 0xd7, 0x9d, 0x66, 0x18, 0x2e, 0xa6, 0x34,
	0x64, 0x63, 0xbc, 0x9d, 0x7d, 0x38, 0x45, 0xce, 0xfd, 0x70, 0xfa, 0x3f, 0x64, 0x08, 0x55, 0x2d,
	0xad, 0x47, 0x74, 0xe2, 0x78, 0x94, 0x33, 0x93, 0x94, 0xd3, 0x84, 0xee, 0x8c, 0x45, 0xc5, 0x97,
	0x02, 0x24, 0xea, 0x8e, 0x7d, 0x48, 0x5c, 0xeb, 0xd2, 0x53, 0xf0, 0x11, 0x2c, 0x3b, 0x4f, 0xed,
	0xf1, 0x8b, 0x81, 0x4f, 0x63, 0xf1, 0x5c, 0xd5, 0x9d, 0x71, 0x9e, 0xda, 0xc1, 0xab, 0xc1, 0x9f,
	0xc7, 0x7f, 0x89, 0x90, 0xaa, 0x3b, 0x56, 0xbf, 0xa7, 0x11, 0x9b, 0xa1, 0x03, 0xde, 0x64, 0xf8,
	0x06, 0xbb, 0xe1, 0x6d, 0x3e, 0x5a, 0xec, 0x06, 0x33, 0x40, 0xe8, 0x01, 0xa4, 0xc7, 0x3b, 0xcd,
	0x66, 0x61, 0x7b, 0x5f, 0x10, 0x77, 0x16, 0xc9, 0x27, 0x9e, 0x07, 0x65, 0x60, 0x9d, 0x87, 0xf8,
	0xc7, 0x78, 0xa0, 0x0c, 0x2c, 0xf4, 0x68, 0xb6, 0x83, 0x06, 0xf5, 0x78, 0xe7, 0x68, 0x98, 0xff,
	0xf4, 0xd4, 0x70, 0x93, 0x38, 0x9e, 0xd4, 0x4a, 0x8b, 0x3f, 0x0a, 0x70, 0x75, 0x62, 0xf1, 0x80,
	0xb0, 0x6e, 0xf0, 0xfc, 0x46, 0x9f, 0x40, 0x6a, 0x7c, 0x25, 0xc6, 0x43, 0x9e, 0xae, 0x5e, 0x9f,
	0x9b, 0x4a, 0x93, 0x43, 0xe1, 0x40, 0x9a, 0x9a, 0xa3, 0x2d, 0xc8, 0x4e, 0x36, 0x6a, 0xf8, 0xdc,
	0x17, 0xf9, 0x73, 0x7f, 0xed, 0x64, 0x88, 0xf0, 0xc9, 0xbf, 0xac, 0xcf, 0x0b, 0x8a, 0xbf, 0x09,
	0xb0, 0x32, 0x31, 0xa2, 0x33, 0xde, 0x5d, 0x76, 0x7a, 0x7f, 0x05, 0xd7, 0x27, 0xbe, 0x50, 0xf5,
	0x29, 0x61, 0xdd, 0xe9, 0x3d, 0xfc, 0x01, 0x5d, 0x38, 0xf9, 0x1e, 0x53, 0x0f, 0xc3, 0xa0, 0xac,
	0xe8, 0x27, 0x78, 0xef, 0x17, 0x6a, 0xb6, 0xad, 0xb9, 0x8c, 0x68, 0xbd, 0x09, 0x27, 0x97, 0x7e,
	0xa5, 0xb9, 0x49, 0x2c, 0x5e, 0xd0, 0x24, 0xbe, 0xf5, 0xab, 0x00, 0xe9, 0x99, 0xbf, 0x36, 0xb4,
	0x06, 0xd2, 0x96, 0xbc, 0x77, 0xd0, 0x56, 0x95, 0xfd, 0xda, 0xfe, 0x81, 0xa2, 0x1e, 0xec, 0x2a,
	0xed, 0x66, 0xbd, 0x75, 0xb7, 0xd5, 0x6c, 0x64, 0x97, 0x90, 0x04, 0x2b, 0x73, 0x5a, 0x79, 0xef,
	0x60, 0xb7, 0xa1, 0x6e, 0x64, 0x85, 0x77, 0x68, 0xaa, 0x59, 0xf1, 0x1d, 0x9a, 0xdb, 0xd9, 0x08,
	0xba, 0x01, 0x57, 0xe7, 0x34, 0xb5, 0xfa, 0x7e, 0xeb, 0xf3, 0x66, 0x36, 0x7a, 0x4c, 0x71, 0xb7,
	0xb6, 0xbd, 0xdd, 0xdc, 0xcd, 0xc6, 0x56, 0xa3, 0xdf, 0xfd, 0x9c, 0x5b, 0xba, 0xc5, 0x60, 0xf9,
	0x5f, 0x99, 0x87, 0x0a, 0xb0, 0x56, 0xdf, 0xdb, 0x69, 0x6f, 0xd7, 0x5a, 0xbb, 0xfb, 0x27, 0xbb,
	0xbe, 0x06, 0xd2, 0x31, 0x0b, 0xe5, 0xa0, 0x5e, 0x6f, 0x2a, 0x4a, 0x56, 0x40, 0x37, 0xe1, 0xc6,
	0x31, 0xed, 0xdd, 0x5a, 0x6b, 0xbb, 0xd9, 0xc8, 0x8a, 0xc1, 0x57, 0x37, 0x3f, 0xfb, 0x65, 0x94,
	0x13, 0x5e, 0x8e, 0x72, 0xc2, 0xab, 0x51, 0x4e, 0xf8, 0x63, 0x94, 0x13, 0x9e, 0xbf, 0xcd, 0x2d,
	0xbd, 0x7a, 0x9b, 0x5b, 0x7a, 0xfd, 0x36, 0xb7, 0xf4, 0xf0, 0x83, 0xf7, 0xd2, 0xf0, 0xcc, 0x27,
	0xa1, 0xc2, 0x06, 0x7d, 0x4c, 0x3b, 0x71, 0xae, 0xbe, 0xfd, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x07, 0x50, 0x00, 0x3c, 0x8e, 0x10, 0x00, 0x00,
}

func (this *Group) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Group)
	if !ok {
		that2, ok := that.(Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.CreateTime.Equal(that1.CreateTime) {
		return false
	}
	if that1.ExpiryTime == nil {
		if this.ExpiryTime != nil {
			return false
		}
	} else if !this.ExpiryTime.Equal(*that1.ExpiryTime) {
		return false
	}
	return true
}
func (this *Round1Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round1Info)
	if !ok {
		that2, ok := that.(Round1Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.CoefficientsCommit) != len(that1.CoefficientsCommit) {
		return false
	}
	for i := range this.CoefficientsCommit {
		if !bytes.Equal(this.CoefficientsCommit[i], that1.CoefficientsCommit[i]) {
			return false
		}
	}
	if !bytes.Equal(this.OneTimePubKey, that1.OneTimePubKey) {
		return false
	}
	if !bytes.Equal(this.A0Sig, that1.A0Sig) {
		return false
	}
	if !bytes.Equal(this.OneTimeSig, that1.OneTimeSig) {
		return false
	}
	return true
}
func (this *Round2Info) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Round2Info)
	if !ok {
		that2, ok := that.(Round2Info)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.EncryptedSecretShares) != len(that1.EncryptedSecretShares) {
		return false
	}
	for i := range this.EncryptedSecretShares {
		if !bytes.Equal(this.EncryptedSecretShares[i], that1.EncryptedSecretShares[i]) {
			return false
		}
	}
	return true
}
func (this *DE) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DE)
	if !ok {
		that2, ok := that.(DE)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	return true
}
func (this *DEQueue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DEQueue)
	if !ok {
		that2, ok := that.(DEQueue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Head != that1.Head {
		return false
	}
	if this.Tail != that1.Tail {
		return false
	}
	return true
}
func (this *Signing) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signing)
	if !ok {
		that2, ok := that.(Signing)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SigningID != that1.SigningID {
		return false
	}
	if this.GroupID != that1.GroupID {
		return false
	}
	if len(this.AssignedMembers) != len(that1.AssignedMembers) {
		return false
	}
	for i := range this.AssignedMembers {
		if !this.AssignedMembers[i].Equal(&that1.AssignedMembers[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Message, that1.Message) {
		return false
	}
	if !bytes.Equal(this.GroupPubNonce, that1.GroupPubNonce) {
		return false
	}
	if !bytes.Equal(this.Commitment, that1.Commitment) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if !this.RequestTime.Equal(that1.RequestTime) {
		return false
	}
	if that1.ExpiryTime == nil {
		if this.ExpiryTime != nil {
			return false
		}
	} else if !this.ExpiryTime.Equal(*that1.ExpiryTime) {
		return false
	}
	return true
}
func (this *AssignedMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignedMember)
	if !ok {
		that2, ok := that.(AssignedMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.Member != that1.Member {
		return false
	}
	if !bytes.Equal(this.PubD, that1.PubD) {
		return false
	}
	if !bytes.Equal(this.PubE, that1.PubE) {
		return false
	}
	if !bytes.Equal(this.PubNonce, that1.PubNonce) {
		return false
	}
	return true
}
func (this *PendingSignings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PendingSignings)
	if !ok {
		that2, ok := that.(PendingSignings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SigningIds) != len(that1.SigningIds) {
		return false
	}
	for i := range this.SigningIds {
		if this.SigningIds[i] != that1.SigningIds[i] {
			return false
		}
	}
	return true
}
func (this *Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Member)
	if !ok {
		that2, ok := that.(Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !bytes.Equal(this.PubKey, that1.PubKey) {
		return false
	}
	if this.IsMalicious != that1.IsMalicious {
		return false
	}
	return true
}
func (this *Confirm) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Confirm)
	if !ok {
		that2, ok := that.(Confirm)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.OwnPubKeySig, that1.OwnPubKeySig) {
		return false
	}
	return true
}
func (this *Complaint) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Complaint)
	if !ok {
		that2, ok := that.(Complaint)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Complainer != that1.Complainer {
		return false
	}
	if this.Complainant != that1.Complainant {
		return false
	}
	if !bytes.Equal(this.KeySym, that1.KeySym) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *ComplaintWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintWithStatus)
	if !ok {
		that2, ok := that.(ComplaintWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Complaint.Equal(&that1.Complaint) {
		return false
	}
	if this.ComplaintStatus != that1.ComplaintStatus {
		return false
	}
	return true
}
func (this *ComplaintsWithStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplaintsWithStatus)
	if !ok {
		that2, ok := that.(ComplaintsWithStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if len(this.ComplaintsWithStatus) != len(that1.ComplaintsWithStatus) {
		return false
	}
	for i := range this.ComplaintsWithStatus {
		if !this.ComplaintsWithStatus[i].Equal(&that1.ComplaintsWithStatus[i]) {
			return false
		}
	}
	return true
}
func (this *PartialSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PartialSignature)
	if !ok {
		that2, ok := that.(PartialSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MemberID != that1.MemberID {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryTime != nil {
		n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ExpiryTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ExpiryTime):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTss(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x3a
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTss(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x32
	if m.Status != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x22
	}
	if m.Threshold != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Size_ != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round1Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round1Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round1Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OneTimeSig) > 0 {
		i -= len(m.OneTimeSig)
		copy(dAtA[i:], m.OneTimeSig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimeSig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.A0Sig) > 0 {
		i -= len(m.A0Sig)
		copy(dAtA[i:], m.A0Sig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.A0Sig)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OneTimePubKey) > 0 {
		i -= len(m.OneTimePubKey)
		copy(dAtA[i:], m.OneTimePubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OneTimePubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CoefficientsCommit) > 0 {
		for iNdEx := len(m.CoefficientsCommit) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CoefficientsCommit[iNdEx])
			copy(dAtA[i:], m.CoefficientsCommit[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.CoefficientsCommit[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Round2Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round2Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Round2Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedSecretShares) > 0 {
		for iNdEx := len(m.EncryptedSecretShares) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedSecretShares[iNdEx])
			copy(dAtA[i:], m.EncryptedSecretShares[iNdEx])
			i = encodeVarintTss(dAtA, i, uint64(len(m.EncryptedSecretShares[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DEQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DEQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DEQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tail != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Tail))
		i--
		dAtA[i] = 0x10
	}
	if m.Head != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Head))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Signing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryTime != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.ExpiryTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.ExpiryTime):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintTss(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x4a
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.RequestTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTss(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x42
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Commitment) > 0 {
		i -= len(m.Commitment)
		copy(dAtA[i:], m.Commitment)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Commitment)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GroupPubNonce) > 0 {
		i -= len(m.GroupPubNonce)
		copy(dAtA[i:], m.GroupPubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.GroupPubNonce)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AssignedMembers) > 0 {
		for iNdEx := len(m.AssignedMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssignedMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.GroupID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x10
	}
	if m.SigningID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.SigningID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssignedMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignedMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignedMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubNonce) > 0 {
		i -= len(m.PubNonce)
		copy(dAtA[i:], m.PubNonce)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubNonce)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PubE) > 0 {
		i -= len(m.PubE)
		copy(dAtA[i:], m.PubE)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubE)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubD) > 0 {
		i -= len(m.PubD)
		copy(dAtA[i:], m.PubD)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubD)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Member) > 0 {
		i -= len(m.Member)
		copy(dAtA[i:], m.Member)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Member)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingSignings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingSignings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingSignings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		dAtA6 := make([]byte, len(m.SigningIds)*10)
		var j5 int
		for _, num := range m.SigningIds {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTss(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMalicious {
		i--
		if m.IsMalicious {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTss(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Confirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Confirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Confirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnPubKeySig) > 0 {
		i -= len(m.OwnPubKeySig)
		copy(dAtA[i:], m.OwnPubKeySig)
		i = encodeVarintTss(dAtA, i, uint64(len(m.OwnPubKeySig)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Complaint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Complaint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Complaint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeySym) > 0 {
		i -= len(m.KeySym)
		copy(dAtA[i:], m.KeySym)
		i = encodeVarintTss(dAtA, i, uint64(len(m.KeySym)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Complainant != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Complainant))
		i--
		dAtA[i] = 0x10
	}
	if m.Complainer != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.Complainer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplaintWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComplaintStatus != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.ComplaintStatus))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Complaint.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTss(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ComplaintsWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplaintsWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplaintsWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ComplaintsWithStatus) > 0 {
		for iNdEx := len(m.ComplaintsWithStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ComplaintsWithStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTss(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartialSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialSignature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialSignature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTss(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.MemberID != 0 {
		i = encodeVarintTss(dAtA, i, uint64(m.MemberID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTss(dAtA []byte, offset int, v uint64) int {
	offset -= sovTss(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	if m.Size_ != 0 {
		n += 1 + sovTss(uint64(m.Size_))
	}
	if m.Threshold != 0 {
		n += 1 + sovTss(uint64(m.Threshold))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTss(uint64(m.Status))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovTss(uint64(l))
	if m.ExpiryTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ExpiryTime)
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Round1Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.CoefficientsCommit) > 0 {
		for _, b := range m.CoefficientsCommit {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.OneTimePubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.A0Sig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.OneTimeSig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Round2Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.EncryptedSecretShares) > 0 {
		for _, b := range m.EncryptedSecretShares {
			l = len(b)
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *DE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *DEQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != 0 {
		n += 1 + sovTss(uint64(m.Head))
	}
	if m.Tail != 0 {
		n += 1 + sovTss(uint64(m.Tail))
	}
	return n
}

func (m *Signing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigningID != 0 {
		n += 1 + sovTss(uint64(m.SigningID))
	}
	if m.GroupID != 0 {
		n += 1 + sovTss(uint64(m.GroupID))
	}
	if len(m.AssignedMembers) > 0 {
		for _, e := range m.AssignedMembers {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.GroupPubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Commitment)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.RequestTime)
	n += 1 + l + sovTss(uint64(l))
	if m.ExpiryTime != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.ExpiryTime)
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *AssignedMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Member)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubD)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubE)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubNonce)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *PendingSignings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SigningIds) > 0 {
		l = 0
		for _, e := range m.SigningIds {
			l += sovTss(uint64(e))
		}
		n += 1 + sovTss(uint64(l)) + l
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	if m.IsMalicious {
		n += 2
	}
	return n
}

func (m *Confirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.OwnPubKeySig)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *Complaint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Complainer != 0 {
		n += 1 + sovTss(uint64(m.Complainer))
	}
	if m.Complainant != 0 {
		n += 1 + sovTss(uint64(m.Complainant))
	}
	l = len(m.KeySym)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func (m *ComplaintWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Complaint.Size()
	n += 1 + l + sovTss(uint64(l))
	if m.ComplaintStatus != 0 {
		n += 1 + sovTss(uint64(m.ComplaintStatus))
	}
	return n
}

func (m *ComplaintsWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	if len(m.ComplaintsWithStatus) > 0 {
		for _, e := range m.ComplaintsWithStatus {
			l = e.Size()
			n += 1 + l + sovTss(uint64(l))
		}
	}
	return n
}

func (m *PartialSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MemberID != 0 {
		n += 1 + sovTss(uint64(m.MemberID))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTss(uint64(l))
	}
	return n
}

func sovTss(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTss(x uint64) (n int) {
	return sovTss(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= GroupStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTime == nil {
				m.ExpiryTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ExpiryTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round1Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round1Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round1Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoefficientsCommit", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoefficientsCommit = append(m.CoefficientsCommit, make([]byte, postIndex-iNdEx))
			copy(m.CoefficientsCommit[len(m.CoefficientsCommit)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimePubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimePubKey = append(m.OneTimePubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimePubKey == nil {
				m.OneTimePubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A0Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A0Sig = append(m.A0Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.A0Sig == nil {
				m.A0Sig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneTimeSig = append(m.OneTimeSig[:0], dAtA[iNdEx:postIndex]...)
			if m.OneTimeSig == nil {
				m.OneTimeSig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round2Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round2Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round2Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecretShares", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedSecretShares = append(m.EncryptedSecretShares, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedSecretShares[len(m.EncryptedSecretShares)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DEQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DEQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DEQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			m.Head = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Head |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningID", wireType)
			}
			m.SigningID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigningID |= github_com_bandprotocol_chain_v2_pkg_tss.SigningID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= github_com_bandprotocol_chain_v2_pkg_tss.GroupID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedMembers = append(m.AssignedMembers, AssignedMember{})
			if err := m.AssignedMembers[len(m.AssignedMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupPubNonce = append(m.GroupPubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.GroupPubNonce == nil {
				m.GroupPubNonce = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commitment = append(m.Commitment[:0], dAtA[iNdEx:postIndex]...)
			if m.Commitment == nil {
				m.Commitment = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.RequestTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTime == nil {
				m.ExpiryTime = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.ExpiryTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignedMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignedMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignedMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Member = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubD", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubD = append(m.PubD[:0], dAtA[iNdEx:postIndex]...)
			if m.PubD == nil {
				m.PubD = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubE", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubE = append(m.PubE[:0], dAtA[iNdEx:postIndex]...)
			if m.PubE == nil {
				m.PubE = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubNonce = append(m.PubNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.PubNonce == nil {
				m.PubNonce = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingSignings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingSignings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingSignings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SigningIds = append(m.SigningIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTss
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTss
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTss
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SigningIds) == 0 {
					m.SigningIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTss
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SigningIds = append(m.SigningIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMalicious", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMalicious = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Confirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Confirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Confirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnPubKeySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnPubKeySig = append(m.OwnPubKeySig[:0], dAtA[iNdEx:postIndex]...)
			if m.OwnPubKeySig == nil {
				m.OwnPubKeySig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Complaint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Complaint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Complaint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complainer", wireType)
			}
			m.Complainer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Complainer |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complainant", wireType)
			}
			m.Complainant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Complainant |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeySym", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeySym = append(m.KeySym[:0], dAtA[iNdEx:postIndex]...)
			if m.KeySym == nil {
				m.KeySym = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Complaint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Complaint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintStatus", wireType)
			}
			m.ComplaintStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplaintStatus |= ComplaintStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplaintsWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplaintsWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplaintsWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplaintsWithStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComplaintsWithStatus = append(m.ComplaintsWithStatus, ComplaintWithStatus{})
			if err := m.ComplaintsWithStatus[len(m.ComplaintsWithStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberID", wireType)
			}
			m.MemberID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberID |= github_com_bandprotocol_chain_v2_pkg_tss.MemberID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTss
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTss
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTss(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTss
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTss
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTss
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTss
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTss        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTss          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTss = fmt.Errorf("proto: unexpected end of group")
)
