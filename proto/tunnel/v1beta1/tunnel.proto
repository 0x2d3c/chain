syntax = "proto3";
package tunnel.v1beta1;

import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/any.proto";
import "cosmos_proto/cosmos.proto";

import "feeds/v1beta1/feeds.proto";

option go_package            = "github.com/bandprotocol/chain/v2/x/tunnel/types";
option (gogoproto.equal_all) = true;

// Route is the type for a route
message TSSRoute {
  option (cosmos_proto.implements_interface) = "RouteI";

  string destination_chain_id         = 1 [(gogoproto.customname) = "DestinationChainID"];
  string destination_contract_address = 2;
}

// AxelarRoute is the type for an Axelar route
message AxelarRoute {
  option (cosmos_proto.implements_interface) = "RouteI";

  string destination_chain_id         = 1 [(gogoproto.customname) = "DestinationChainID"];
  string destination_contract_address = 2;
}

// SignalInfo is the type for a signal info
message SignalInfo {
  option (gogoproto.equal) = true;

  string signal_id     = 1 [(gogoproto.customname) = "SignalID"];
  uint64 deviation_bps = 2 [(gogoproto.customname) = "DeviationBPS"];
  int64  interval      = 3;
}

// SignalPriceInfo is the type for a signal price info
message SignalPriceInfo {
  option (gogoproto.equal) = true;

  string signal_id      = 1 [(gogoproto.customname) = "SignalID"];
  uint64 deviation_bps  = 2 [(gogoproto.customname) = "DeviationBPS"];
  int64  interval       = 3;
  uint64 price          = 4;
  int64  last_timestamp = 5;
}

// Tunnel is the type for a tunnel
message Tunnel {
  option (gogoproto.equal) = true;

  uint64                   id                          = 1 [(gogoproto.customname) = "ID"];
  uint64                   nonce_count                 = 2;
  google.protobuf.Any      route                       = 3 [(cosmos_proto.accepts_interface) = "RouteI"];
  feeds.v1beta1.FeedType   feed_type                   = 4;
  string                   fee_payer                   = 5 [(cosmos_proto.scalar) = "cosmos.AddressString"];
  repeated SignalPriceInfo signal_price_infos          = 6 [(gogoproto.nullable) = false];
  uint64                   last_triggered_block_height = 7;
  bool                     is_active                   = 8;
  int64                    created_at                  = 9;
  string                   creator                     = 10 [(cosmos_proto.scalar) = "cosmos.AddressString"];
}

// PendingTriggerTunnels is the type for a list of tunnel IDs that are waiting to be triggered
message PendingTriggerTunnels {
  // IDs is a list of tunnel IDs that are waiting to be triggered
  repeated uint64 ids = 1 [(gogoproto.customname) = "IDs"];
}

// Packet is the packet that tunnel produces
message Packet {
  uint64                   tunnel_id          = 1 [(gogoproto.customname) = "TunnelID"];
  uint64                   nonce              = 2;
  feeds.v1beta1.FeedType   feed_type          = 3;
  repeated SignalPriceInfo signal_price_infos = 4 [(gogoproto.nullable) = false];
  google.protobuf.Any      packet_content     = 5 [(cosmos_proto.accepts_interface) = "PacketContentI"];
  int64                    created_at         = 6;
}

// TSSPacketContent is the packet content for TSS
message TSSPacketContent {
  option (cosmos_proto.implements_interface) = "PacketContentI";

  uint64 signing_id = 1 [
    (gogoproto.customname) = "SigningID",
    (gogoproto.casttype)   = "github.com/bandprotocol/chain/v2/x/bandtss/types.SigningID"
  ];
  string destination_chain_id         = 2 [(gogoproto.customname) = "DestinationChainID"];
  string destination_contract_address = 3;
}

// AxelarPacketContent is the packet content for Axelar
message AxelarPacketContent {
  option (cosmos_proto.implements_interface) = "PacketContentI";

  uint64 ibc_queue_id                 = 1 [(gogoproto.customname) = "IBCQueueID"];
  string destination_chain_id         = 2 [(gogoproto.customname) = "DestinationChainID"];
  string destination_contract_address = 3;
}
