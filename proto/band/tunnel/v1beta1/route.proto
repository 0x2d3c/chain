syntax = "proto3";
package band.tunnel.v1beta1;

import "cosmos_proto/cosmos.proto";
import "gogoproto/gogo.proto";

import "band/feeds/v1beta1/feeds.proto";

option go_package            = "github.com/bandprotocol/chain/v3/x/tunnel/types";
option (gogoproto.equal_all) = true;

// TSSRoute is the type for a TSS route
message TSSRoute {
  option (cosmos_proto.implements_interface) = "RouteI";

  // destination_chain_id is the destination chain ID
  string destination_chain_id = 1 [(gogoproto.customname) = "DestinationChainID"];
  // destination_contract_address is the destination contract address
  string destination_contract_address = 2;
}

// TSSRouteResult is the type for a TSS route result
message TSSRouteResult {
  option (cosmos_proto.implements_interface) = "RouteResultI";

  // signing_id is the signing ID
  uint64 signing_id = 1 [
    (gogoproto.customname) = "SigningID",
    (gogoproto.casttype)   = "github.com/bandprotocol/chain/v3/x/bandtss/types.SigningID"
  ];
}

// IBCRoute is the type for an IBC route
message IBCRoute {
  option (cosmos_proto.implements_interface) = "Route";

  // channel_id is the IBC channel ID
  string channel_id = 1 [(gogoproto.customname) = "ChannelID"];
}

// IBCRouteResult is the type for an IBC route result
message IBCRouteResult {
  option (cosmos_proto.implements_interface) = "PacketContentI";

  // sequence is representing the sequence of the IBC packet.
  uint64 sequence = 2;
}

// IBCPacket is the type for an IBC packet
message IBCPacket {
  // tunnel_id is the tunnel ID
  uint64 tunnel_id = 1 [(gogoproto.customname) = "TunnelID"];
  // sequence is representing the sequence of the tunnel packet.
  uint64 sequence = 2;
  // prices is the list of prices information from feeds module.
  repeated band.feeds.v1beta1.Price prices = 3 [(gogoproto.nullable) = false];
  // created_at is the timestamp when the packet is created
  int64 created_at = 4;
}
